<!DOCTYPE html>
<html lang="en">

<head>
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
    <meta http-equiv="Pragma" content="no-cache" />
    <meta http-equiv="Expires" content="0" />
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Loading... | Market Watch Expert</title>
    <link rel="icon" href="https://market-watch.xyz/favicon.ico">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700;800&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom@2.0.1/dist/chartjs-plugin-zoom.min.js"></script>
    <link rel="stylesheet" href="/styles.css">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background: #f8fafc;
            color: #0f172a;
        }

        .mw-card {
            background: white;
            border-radius: 12px;
            padding: 1.5rem;
            box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06);
            border: 1px solid #e2e8f0;
            margin-bottom: 2rem;
        }

        .hero-stat {
            text-align: center;
            padding: 1.25rem;
            background: white;
            border: 1px solid #e2e8f0;
            border-radius: 12px;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);
        }

        .nav-tabs {
            display: flex;
            gap: 4px;
            background: #f1f5f9;
            padding: 4px;
            border-radius: 10px;
            margin-bottom: 2rem;
            overflow-x: auto;
            -webkit-overflow-scrolling: touch;
        }

        .nav-tab {
            padding: 0.5rem 1rem;
            font-weight: 600;
            color: #64748b;
            cursor: pointer;
            border-radius: 8px;
            transition: all 0.2s;
            white-space: nowrap;
            flex: 1;
            text-align: center;
            font-size: 0.85rem;
        }

        .nav-tab.active {
            background: white;
            color: #2563eb;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }

        .period-btn {
            padding: 4px 10px;
            border-radius: 6px;
            font-weight: 600;
            font-size: 0.7rem;
            transition: all 0.15s;
            border: 1px solid transparent;
        }

        .period-btn.active {
            background: #2563eb;
            color: white;
            border-color: #2563eb;
        }

        .period-btn.inactive {
            background: #f8fafc;
            color: #64748b;
            border-color: #e2e8f0;
        }

        .hidden {
            display: none;
        }

        /* Custom Scrollbar */
        ::-webkit-scrollbar {
            width: 6px;
            height: 6px;
        }

        ::-webkit-scrollbar-track {
            background: transparent;
        }

        ::-webkit-scrollbar-thumb {
            background: #cbd5e1;
            border-radius: 3px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #94a3b8;
        }

        /* Tooltip Styles */
        .tooltip-wrapper {
            position: relative;
            display: inline-block;
            margin-left: 4px;
        }

        .info-icon {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: #cbd5e1;
            color: white;
            font-size: 10px;
            font-weight: bold;
            cursor: help;
            transition: all 0.2s;
        }

        .info-icon:hover {
            background: #3b82f6;
        }

        .tooltip-text {
            visibility: hidden;
            opacity: 0;
            width: 250px;
            background-color: #1e293b;
            color: white;
            text-align: left;
            border-radius: 6px;
            padding: 8px 12px;
            position: absolute;
            z-index: 1000;
            bottom: 125%;
            left: 50%;
            margin-left: -125px;
            font-size: 11px;
            line-height: 1.4;
            transition: opacity 0.2s;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
        }

        .tooltip-text::after {
            content: "";
            position: absolute;
            top: 100%;
            left: 50%;
            margin-left: -5px;
            border-width: 5px;
            border-style: solid;
            border-color: #1e293b transparent transparent transparent;
        }

        .tooltip-wrapper:hover .tooltip-text {
            visibility: visible;
            opacity: 1;
        }

        /* Custom Scrollbar for Drift Lists */
        .custom-scrollbar::-webkit-scrollbar {
            width: 4px;
        }

        .custom-scrollbar::-webkit-scrollbar-track {
            background: transparent;
        }

        .custom-scrollbar::-webkit-scrollbar-thumb {
            background: #cbd5e1;
            border-radius: 2px;
        }

        .custom-scrollbar::-webkit-scrollbar-thumb:hover {
            background: #94a3b8;
        }

        /* Drift Alert Badges */
        .drift-badge {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 10px;
            font-weight: bold;
            text-transform: uppercase;
        }

        .drift-badge.low {
            background: #d1fae5;
            color: #065f46;
        }

        .drift-badge.medium {
            background: #fed7aa;
            color: #9a3412;
        }

        .drift-badge.high {
            background: #fecaca;
            color: #991b1b;
        }

        .drift-badge.critical {
            background: #e0e7ff;
            color: #3730a3;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {

            0%,
            100% {
                opacity: 1;
            }

            50% {
                opacity: 0.7;
            }
        }
    </style>
</head>

<body class="bg-slate-50 min-h-screen flex flex-col">
    <!-- HEADER -->
    <nav class="bg-white border-b border-slate-200 px-4 py-3 sticky top-0 z-50 shadow-sm">
        <div class="max-w-7xl mx-auto flex items-center justify-between gap-4">
            <div class="flex items-center gap-3">
                <a href="index.html"
                    class="flex items-center justify-center w-8 h-8 rounded-full bg-slate-100 hover:bg-slate-200 transition-colors">
                    <i class="fa-solid fa-arrow-left text-slate-600 text-sm"></i>
                </a>
                <span class="text-lg font-bold text-slate-900">Loading...</span>
                <select id="currency-selector"
                    class="text-xs font-mono bg-slate-100 text-slate-700 font-bold px-2 py-1 rounded border border-slate-200 outline-none cursor-pointer hover:bg-white"
                    onchange="setGlobalCurrency(this.value)">
                    <option value="EUR">ðŸ‡ªðŸ‡º EUR</option>
                    <option value="USD">ðŸ‡ºðŸ‡¸ USD</option>
                    <option value="CHF">ðŸ‡¨ðŸ‡­ CHF</option>
                    <option value="HKD" selected>ðŸ‡­ðŸ‡° HKD</option>
                    <option value="JPY">ðŸ‡¯ðŸ‡µ JPY</option>
                    <option value="CNY">ðŸ‡¨ðŸ‡³ CNY</option>
                    <option value="GBP">ðŸ‡¬ðŸ‡§ GBP</option>
                    <option value="PLN">ðŸ‡µðŸ‡± PLN</option>
                    <option value="BTC">â‚¿ BTC</option>
                    <option value="GOLD">ðŸ¥‡ GOLD</option>
                </select>
            </div>

            <div class="flex items-center gap-1 bg-slate-100 p-1 rounded-lg" id="period-selector">
                <!-- Period buttons will be injected here -->
            </div>

            <!-- Live Trading Link -->
            <a href="live.html"
                class="flex items-center gap-2 px-3 py-1.5 bg-red-50 text-red-600 rounded-lg hover:bg-red-100 transition font-semibold text-sm border border-red-200">
                <span class="relative flex h-2 w-2">
                    <span
                        class="animate-ping absolute inline-flex h-full w-full rounded-full bg-red-400 opacity-75"></span>
                    <span class="relative inline-flex rounded-full h-2 w-2 bg-red-500"></span>
                </span>
                Live
            </a>

            <div class="flex items-center gap-3">
                <div class="flex flex-col items-end">
                    <div class="text-xs uppercase font-bold text-blue-600 tracking-wider">Time Machine</div>
                    <div id="tm-date" class="font-mono text-sm font-bold text-slate-700">LIVE</div>
                </div>
                <input type="range" id="timeSlider"
                    class="w-32 md:w-40 h-2 bg-slate-200 rounded-lg appearance-none cursor-pointer">
            </div>
        </div>
    </nav>

    <!-- CONTENT -->
    <main class="max-w-7xl mx-auto px-4 py-8 flex-grow w-full">
        <div class="nav-tabs">
            <div class="nav-tab active" onclick="switchTab('dashboard')"><i
                    class="fa-solid fa-chart-line mr-2"></i>Dashboard</div>
            <div class="nav-tab" onclick="switchTab('positions')"><i class="fa-solid fa-layer-group mr-2"></i>Positions
            </div>
            <div class="nav-tab" onclick="switchTab('risk')"><i class="fa-solid fa-shield-halved mr-2"></i>Risk &
                Analysis</div>
            <div class="nav-tab" onclick="switchTab('ideas')"><i class="fa-solid fa-brain mr-2"></i>Trade Ideas</div>
            <div class="nav-tab" onclick="switchTab('drift')"><i class="fa-solid fa-wave-square mr-2"></i>Drift &
                Quality</div>
            <div class="nav-tab" onclick="switchTab('logs')"><i class="fa-solid fa-list-ul mr-2"></i>Journal</div>
        </div>

        <!-- DASHBOARD -->
        <div id="tab-dashboard" class="tab-content">
            <div class="grid grid-cols-2 md:grid-cols-4 gap-4 mb-8">
                <div class="hero-stat">
                    <div class="text-xs uppercase font-bold text-slate-400 mb-1">Period Return</div>
                    <div class="text-2xl font-black" id="kpi-return">--%</div>
                </div>
                <div class="hero-stat">
                    <div class="text-xs uppercase font-bold text-slate-400 mb-1">Win Rate</div>
                    <div class="text-2xl font-black text-emerald-600" id="kpi-winrate">--%</div>
                </div>
                <div class="hero-stat">
                    <div class="text-xs uppercase font-bold text-slate-400 mb-1">Volatility</div>
                    <div class="text-2xl font-black text-purple-600" id="kpi-vol">--%</div>
                </div>
                <div class="hero-stat">
                    <div class="text-xs uppercase font-bold text-slate-400 mb-1">Max Drawdown</div>
                    <div class="text-2xl font-black text-rose-600" id="kpi-dd">--%</div>
                </div>
            </div>

            <div class="grid md:grid-cols-3 gap-6 mb-8">
                <div class="mw-card md:col-span-2">
                    <div class="flex justify-between items-center mb-4">
                        <h3 class="font-bold text-lg text-slate-800">Performance Curve</h3>
                        <div id="pnl-legend" class="text-xs flex gap-2"></div>
                    </div>
                    <div class="h-[400px]"><canvas id="equityChart"></canvas></div>
                </div>
                <div class="mw-card col-span-1">
                    <div class="flex justify-between items-center mb-6">
                        <h3 class="font-bold text-sm text-slate-500 uppercase flex items-center gap-2">
                            <i class="fa-solid fa-camera text-slate-400"></i> Snapshot Stats
                        </h3>
                        <button onclick="openStatsConfig()"
                            class="text-slate-400 hover:text-slate-600 transition-colors p-1 rounded hover:bg-slate-100"
                            title="Configure Stats">
                            <i class="fa-solid fa-gear"></i>
                        </button>
                    </div>

                    <div id="stats-grid" class="grid grid-cols-2 gap-4">
                        <!-- JS Rendered -->
                    </div>
                </div>


            </div>


            <div class="grid md:grid-cols-2 gap-6 mb-8">
                <div class="mw-card">
                    <h4 class="font-bold text-slate-800 mb-4">Capital Allocation</h4>
                    <div class="h-64"><canvas id="allocChart"></canvas></div>
                </div>
                <div class="mw-card">
                    <h4 class="font-bold text-slate-800 mb-4">Top Holdings</h4>
                    <div id="top-holdings-list" class="space-y-2 h-64 overflow-y-auto pr-2 custom-scrollbar"></div>
                </div>
            </div>

            <!-- Allocation Grid: Sector, Region, Industry, Asset Type, Market Cap -->
            <div class="grid md:grid-cols-2 lg:grid-cols-3 gap-6 mb-8">
                <div class="mw-card">
                    <h3 class="font-bold text-lg text-slate-800 mb-4"><i
                            class="fa-solid fa-industry text-blue-500 mr-2"></i>Sector Allocation</h3>
                    <div class="flex justify-center" style="height: 280px;">
                        <canvas id="sector-breakdown"></canvas>
                    </div>
                </div>
                <div class="mw-card">
                    <h3 class="font-bold text-lg text-slate-800 mb-4"><i
                            class="fa-solid fa-earth-americas text-emerald-500 mr-2"></i>Region Allocation</h3>
                    <div class="flex justify-center" style="height: 280px;">
                        <canvas id="region-breakdown"></canvas>
                    </div>
                </div>
                <!-- New Actual Country Allocation -->
                <div class="mw-card">
                    <h3 class="font-bold text-lg text-slate-800 mb-4"><i
                            class="fa-solid fa-flag text-emerald-500 mr-2"></i>Country Allocation</h3>
                    <div class="flex justify-center" style="height: 280px;">
                        <canvas id="country-breakdown"></canvas>
                    </div>
                </div>
                <!-- New Currency Allocation Chart -->
                <div class="mw-card">
                    <h3 class="font-bold text-lg text-slate-800 mb-4"><i
                            class="fa-solid fa-money-bill-wave text-teal-500 mr-2"></i>Currency Allocation</h3>
                    <div class="flex justify-center" style="height: 280px;">
                        <canvas id="currency-breakdown"></canvas>
                    </div>
                </div>
                <!-- New Asset Class Allocation Chart -->
                <div class="mw-card">
                    <h3 class="font-bold text-lg text-slate-800 mb-4"><i
                            class="fa-solid fa-shapes text-indigo-500 mr-2"></i>Asset Class</h3>
                    <div class="flex justify-center" style="height: 280px;">
                        <canvas id="asset-class-breakdown"></canvas>
                    </div>
                </div>
                <div class="mw-card">
                    <h3 class="font-bold text-lg text-slate-800 mb-4"><i
                            class="fa-solid fa-layer-group text-purple-500 mr-2"></i>Industry Allocation</h3>
                    <div class="flex justify-center" style="height: 280px;">
                        <canvas id="industry-breakdown"></canvas>
                    </div>
                </div>
                <div class="mw-card">
                    <h3 class="font-bold text-lg text-slate-800 mb-4"><i
                            class="fa-solid fa-boxes-stacked text-orange-500 mr-2"></i>Asset Type</h3>
                    <div class="flex justify-center" style="height: 280px;">
                        <canvas id="asset-type-breakdown"></canvas>
                    </div>
                </div>
                <!-- Market Cap Chart Removed (Data Missing) -->

                <div class="mw-card">
                    <h3 class="font-bold text-lg text-slate-800 mb-4"><i
                            class="fa-solid fa-tags text-indigo-500 mr-2"></i>Thematic Allocation</h3>
                    <div class="flex justify-center" style="height: 280px;">
                        <canvas id="theme-breakdown"></canvas>
                    </div>
                </div>
            </div>



            <div class="grid md:grid-cols-2 gap-6">
                <div class="mw-card">
                    <h4 class="font-bold text-slate-800 mb-4 flex items-center gap-2"><i
                            class="fa-solid fa-trophy text-yellow-500"></i> Top 3 Best Trades</h4>
                    <div id="best-trades-list" class="space-y-2"></div>
                </div>
                <div class="mw-card">
                    <h4 class="font-bold text-slate-800 mb-4 flex items-center gap-2"><i
                            class="fa-solid fa-skull text-rose-500"></i> Top 3 Worst Trades</h4>
                    <div id="worst-trades-list" class="space-y-2"></div>
                </div>
            </div>
        </div>

        <!-- POSITIONS TAB -->
        <div id="tab-positions" class="tab-content hidden">
            <div class="mw-card mb-8">
                <div class="flex justify-between items-center mb-6 border-b border-slate-100 pb-4">
                    <h3 class="font-bold text-lg text-slate-800">Open Positions</h3>
                    <div class="flex flex-wrap items-center gap-2">
                        <!-- Count -->
                        <div
                            class="px-3 py-1 rounded-full bg-slate-100 border border-slate-200 flex items-center gap-2 shadow-sm">
                            <span class="text-[10px] uppercase font-bold text-slate-500 tracking-wider">Count</span>
                            <span id="header-count" class="text-xs font-bold text-slate-700">--</span>
                        </div>

                        <!-- Stats Button with Popover -->
                        <div class="relative">
                            <button id="btn-stats-toggle" onclick="toggleStatsPopover(event)"
                                class="flex items-center gap-2 px-3 py-1.5 rounded-lg bg-white border border-slate-200 shadow-sm hover:bg-slate-50 transition-all focus:outline-none active:scale-95 group">
                                <i
                                    class="fa-solid fa-chart-pie text-indigo-500 text-xs group-hover:text-indigo-600"></i>
                                <span class="text-xs font-bold text-slate-600 group-hover:text-slate-800">Stats</span>
                            </button>
                            <!-- Popover (Wider: w-80) -->
                            <div id="popover-stats"
                                class="absolute right-0 top-full mt-2 w-[480px] bg-white rounded-xl shadow-xl border border-slate-200 p-0 hidden z-50 transform origin-top-right transition-all duration-200">
                                <div class="p-4 space-y-3">
                                    <div class="flex justify-between items-center">
                                        <div class="flex flex-col">
                                            <span class="text-[10px] text-slate-400 uppercase font-bold">Positions
                                                Value</span>
                                            <span id="pop-unrealized-pct"
                                                class="text-[10px] font-medium text-slate-500">--%</span>
                                        </div>
                                        <span id="pop-unrealized-val" class="font-bold text-slate-800">--</span>
                                    </div>
                                    <div class="flex justify-between items-center">
                                        <div class="flex flex-col">
                                            <span class="text-[10px] text-slate-400 uppercase font-bold">Realized
                                                P&L</span>
                                            <span id="pop-realized-pct"
                                                class="text-[10px] font-medium text-slate-500">--%</span>
                                        </div>
                                        <span id="pop-realized-val" class="font-bold text-slate-800">--</span>
                                    </div>
                                    <div class="border-t border-slate-100 my-1"></div>
                                    <div class="flex justify-between items-center">
                                        <div class="flex flex-col">
                                            <span class="text-[10px] text-slate-400 uppercase font-bold">Total
                                                Equity</span>
                                            <span id="pop-equity-pct"
                                                class="text-[10px] font-bold text-indigo-600">--%</span>
                                        </div>
                                        <span id="pop-equity-val" class="font-bold text-base text-slate-900">--</span>
                                    </div>
                                </div>
                                <div class="px-4 py-3 bg-rose-50 rounded-b-xl border-t border-rose-100">
                                    <div class="flex justify-between items-center mb-1">
                                        <div class="flex flex-col">
                                            <span class="text-[10px] text-rose-600 uppercase font-bold">Max Loss</span>
                                            <span id="pop-maxloss-pct"
                                                class="text-[10px] font-medium text-rose-500">--%</span>
                                        </div>
                                        <span id="pop-maxloss-val" class="font-bold text-base text-rose-600">--</span>
                                    </div>
                                    <div class="text-[9px] text-rose-400 italic text-center leading-tight">
                                        Potential loss if all active Stop-Losses are executed immediately.
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- Actions -->
                        <div class="ml-2 border-l pl-4 border-slate-200">
                            <div class="flex items-center bg-slate-100 rounded-lg p-1 border border-slate-200">
                                <button id="btn-global"
                                    class="px-3 py-1 text-xs font-bold rounded-md bg-white text-blue-600 shadow-sm"
                                    onclick="setCurrencyMode('GLOBAL')">Global Curr.</button>
                                <button id="btn-native" class="px-3 py-1 text-xs font-bold rounded-md text-slate-500"
                                    onclick="setCurrencyMode('NATIVE')">Native Curr.</button>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="overflow-x-auto">
                    <table class="w-full text-left text-sm">
                        <thead class="bg-slate-50 text-slate-500 uppercase text-xs font-bold">
                            <tr>
                                <th class="px-4 py-3 cursor-pointer hover:bg-slate-100 transition-colors"
                                    onclick="toggleSort('pos', 'symbol')">Symbol <i
                                        class="fa-solid fa-sort ml-1 opacity-30"></i></th>
                                <th class="px-4 py-3 text-right cursor-pointer hover:bg-slate-100 transition-colors"
                                    onclick="toggleSort('pos', 'shares')">Shares <i
                                        class="fa-solid fa-sort ml-1 opacity-30"></i></th>
                                <th class="px-4 py-3 text-right cursor-pointer hover:bg-slate-100 transition-colors"
                                    onclick="toggleSort('pos', 'avg_cost')">Avg Cost <i
                                        class="fa-solid fa-sort ml-1 opacity-30"></i></th>
                                <th class="px-4 py-3 text-right cursor-pointer hover:bg-slate-100 transition-colors"
                                    onclick="toggleSort('pos', 'price')">Price <i
                                        class="fa-solid fa-sort ml-1 opacity-30"></i></th>
                                <th class="px-4 py-3 text-right cursor-pointer hover:bg-slate-100 transition-colors"
                                    onclick="toggleSort('pos', 'value')">Value <i
                                        class="fa-solid fa-sort ml-1 opacity-30"></i></th>
                                <th class="px-4 py-3 text-right cursor-pointer hover:bg-slate-100 transition-colors"
                                    onclick="toggleSort('pos', 'pnl')">P&L <i
                                        class="fa-solid fa-sort ml-1 opacity-30"></i></th>
                                <th class="px-4 py-3 text-right cursor-pointer hover:bg-slate-100 transition-colors"
                                    onclick="toggleSort('pos', 'duration')">Duration <i
                                        class="fa-solid fa-sort ml-1 opacity-30"></i></th>
                                <th class="px-4 py-3 text-right cursor-pointer hover:bg-slate-100 transition-colors"
                                    onclick="toggleSort('pos', 'weight')">Weight <i
                                        class="fa-solid fa-sort ml-1 opacity-30"></i></th>
                                <th class="px-4 py-3 text-right cursor-pointer hover:bg-slate-100 transition-colors"
                                    onclick="toggleSort('pos', 'impact')">Impact % <i
                                        class="fa-solid fa-sort ml-1 opacity-30"></i></th>
                            </tr>
                        </thead>
                        <tbody id="pos-body" class="divide-y divide-slate-100"></tbody>
                    </table>
                </div>
            </div>

            <div class="mw-card">
                <div class="flex justify-between items-center mb-4 border-b border-slate-100 pb-4">
                    <h3 class="font-bold text-lg text-slate-800"><i
                            class="fa-solid fa-clock-rotate-left text-blue-500 mr-2"></i>Orders Activity (Session)
                    </h3>
                    <span id="orders-date-label"
                        class="text-xs bg-blue-50 text-blue-700 px-2 py-1 rounded border border-blue-200 font-mono"></span>
                </div>
                <p class="text-sm text-slate-500 mb-4">Pending orders and trades executed on the selected date.</p>
                <div class="overflow-x-auto">
                    <table class="w-full text-left text-sm">
                        <thead class="bg-slate-50 text-slate-500 uppercase text-xs">
                            <tr>
                                <th id="col-orders-time" class="px-4 py-3 text-slate-500 font-mono text-[10px]">Time
                                </th>
                                <th class="px-4 py-3 cursor-pointer hover:bg-slate-100 transition-colors"
                                    onclick="toggleSort('orders', 'symbol')">Symbol <i
                                        class="fa-solid fa-sort ml-1 opacity-30"></i></th>
                                <th class="px-4 py-3 cursor-pointer hover:bg-slate-100 transition-colors"
                                    onclick="toggleSort('orders', 'type')">Type <i
                                        class="fa-solid fa-sort ml-1 opacity-30"></i></th>
                                <th class="px-4 py-3 text-right cursor-pointer hover:bg-slate-100 transition-colors"
                                    onclick="toggleSort('orders', 'qty')">Qty <i
                                        class="fa-solid fa-sort ml-1 opacity-30"></i></th>
                                <th class="px-4 py-3 text-right cursor-pointer hover:bg-slate-100 transition-colors"
                                    onclick="toggleSort('orders', 'price')">Price <i
                                        class="fa-solid fa-sort ml-1 opacity-30"></i></th>
                                <th class="px-4 py-3 text-right cursor-pointer hover:bg-slate-100 transition-colors"
                                    onclick="toggleSort('orders', 'diff')">Diff / P&L <i
                                        class="fa-solid fa-sort ml-1 opacity-30"></i></th>
                                <th class="px-4 py-3 text-right cursor-pointer hover:bg-slate-100 transition-colors"
                                    onclick="toggleSort('orders', 'status')">Status <i
                                        class="fa-solid fa-sort ml-1 opacity-30"></i></th>
                                <th class="px-4 py-3 text-right cursor-pointer hover:bg-slate-100 transition-colors"
                                    onclick="toggleSort('orders', 'created')">Created <i
                                        class="fa-solid fa-sort ml-1 opacity-30"></i></th>
                                <th class="px-4 py-3 text-right cursor-pointer hover:bg-slate-100 transition-colors"
                                    onclick="toggleSort('orders', 'duration')">Duration <i
                                        class="fa-solid fa-sort ml-1 opacity-30"></i></th>
                            </tr>
                        </thead>
                        <tbody id="orders-body" class="divide-y divide-slate-100 font-mono text-sm"></tbody>
                    </table>
                </div>
            </div>
        </div>

        <!-- RISK & STRESS TAB -->
        <div id="tab-risk" class="tab-content hidden">
            <div class="grid md:grid-cols-3 gap-6 mb-8">
                <div class="mw-card col-span-2">
                    <h3 class="font-bold text-lg text-slate-800 mb-2">Risk Profile</h3>
                    <p class="text-sm text-slate-500 mb-6 font-medium">Portfolio Sensitivity (Beta: <span id="risk-beta"
                            class="text-slate-900 font-bold">--</span>)</p>

                    <div class="bg-slate-50 p-6 rounded-xl border border-slate-200">
                        <h4 class="font-bold text-sm text-slate-700 mb-4 border-b border-slate-200 pb-2">Stress Test
                            Simulator</h4>
                        <div class="mb-6">
                            <label class="block text-xs font-bold text-slate-500 uppercase mb-2">Market Crash
                                Scenario
                                (S&P 500 Drop)</label>
                            <input type="range" min="0" max="50" value="10" step="1"
                                class="w-full h-2 bg-slate-200 rounded-lg appearance-none cursor-pointer mb-2"
                                oninput="updateStressTest(this.value)">
                            <div class="flex justify-between text-xs text-slate-400 font-mono">
                                <span>0%</span>
                                <span class="text-slate-600 font-bold" id="stress-slider-val">-10% Drop</span>
                                <span>-50%</span>
                            </div>
                        </div>

                        <div class="grid grid-cols-2 gap-4">
                            <div class="p-3 bg-white rounded border border-slate-200 shadow-sm">
                                <div class="text-xs text-slate-400 uppercase font-bold">Portfolio Impact</div>
                                <div class="text-xl font-black text-rose-500" id="stress-impact-pct">--%</div>
                            </div>
                            <div class="p-3 bg-white rounded border border-slate-200 shadow-sm">
                                <div class="text-xs text-slate-400 uppercase font-bold">Estimated Loss</div>
                                <div class="text-xl font-bold text-slate-700" id="stress-impact-val">--</div>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="mw-card">
                    <h3 class="font-bold text-lg text-slate-800 mb-4">Drawdown Rules</h3>
                    <ul class="text-sm space-y-4 text-slate-600">
                        <li class="flex items-start"><i
                                class="fa-solid fa-triangle-exclamation text-rose-500 mt-1 mr-2"></i>
                            <div><strong>Hard Stop:</strong><br>Portfolio liquidation at -15% DD.</div>
                        </li>
                        <li class="flex items-start"><i class="fa-solid fa-chart-simple text-blue-500 mt-1 mr-2"></i>
                            <div><strong>Sizing:</strong><br>Volatility targeted at 15% annualized.</div>
                        </li>
                        <li class="flex items-start"><i class="fa-solid fa-shield-cat text-emerald-500 mt-1 mr-2"></i>
                            <div><strong>Protection:</strong><br>Trailing stops on all positions active.</div>
                        </li>
                    </ul>
                </div>
            </div>

            <!-- Educational Risk Metrics -->
            <div class="mw-card mb-8">
                <h3 class="font-bold text-lg text-slate-800 mb-6"><i
                        class="fa-solid fa-graduation-cap text-purple-500 mr-2"></i>Risk Metrics</h3>
                <div class="grid md:grid-cols-2 gap-6">
                    <div class="p-4 bg-slate-50 rounded-xl border border-slate-100">
                        <div class="text-xs text-purple-600 uppercase font-bold mb-2">VaR 99% (Value at Risk)</div>
                        <div class="text-2xl font-black text-rose-600 mb-2" id="risk-var">--</div>
                        <p class="text-xs text-slate-500">Estimated maximum daily loss with 99% confidence, based on
                            historical returns.</p>
                    </div>
                    <div class="p-4 bg-slate-50 rounded-xl border border-slate-100">
                        <div class="text-xs text-blue-600 uppercase font-bold mb-2">Beta Portfolio</div>
                        <div class="text-2xl font-black text-slate-800 mb-2" id="risk-beta-val">--</div>
                        <p class="text-xs text-slate-500">Measures portfolio volatility relative to the market (SPY
                            benchmark).</p>
                    </div>
                </div>
            </div>

            <!-- Event Calendar -->
            <div class="mw-card">
                <h3 class="font-bold text-lg text-slate-800 mb-4"><i
                        class="fa-solid fa-calendar-days text-blue-500 mr-2"></i>Upcoming Events</h3>
                <div id="events-list" class="space-y-3">
                    <div class="flex items-center p-3 bg-yellow-50 rounded-lg border border-yellow-100">
                        <div class="w-12 h-12 bg-yellow-100 rounded-lg flex flex-col items-center justify-center mr-4">
                            <div class="text-xs font-bold text-yellow-700">JAN</div>
                            <div class="text-lg font-black text-yellow-800">3</div>
                        </div>
                        <div>
                            <div class="font-bold text-slate-800">US Jobs Report (NFP)</div>
                            <div class="text-xs text-slate-500">High impact event - expect increased volatility
                            </div>
                        </div>
                    </div>
                    <div class="flex items-center p-3 bg-blue-50 rounded-lg border border-blue-100">
                        <div class="w-12 h-12 bg-blue-100 rounded-lg flex flex-col items-center justify-center mr-4">
                            <div class="text-xs font-bold text-blue-700">JAN</div>
                            <div class="text-lg font-black text-blue-800">15</div>
                        </div>
                        <div>
                            <div class="font-bold text-slate-800">Options Expiration (Monthly)</div>
                            <div class="text-xs text-slate-500">Max pain levels may influence price action</div>
                        </div>
                    </div>
                    <div class="flex items-center p-3 bg-purple-50 rounded-lg border border-purple-100">
                        <div class="w-12 h-12 bg-purple-100 rounded-lg flex flex-col items-center justify-center mr-4">
                            <div class="text-xs font-bold text-purple-700">JAN</div>
                            <div class="text-lg font-black text-purple-800">29</div>
                        </div>
                        <div>
                            <div class="font-bold text-slate-800">FOMC Rate Decision</div>
                            <div class="text-xs text-slate-500">Fed meeting - potential policy shift</div>
                        </div>
                    </div>
                </div>
            </div>



            <!-- Correlation Matrix -->
            <div class="mw-card">
                <div class="flex justify-between items-center mb-4">
                    <h3 class="font-bold text-lg text-slate-800"><i
                            class="fa-solid fa-table-cells text-purple-500 mr-2"></i>Position Correlation</h3>
                    <div class="flex items-center gap-2 text-xs">
                        <span class="px-2 py-0.5 bg-slate-200 text-slate-600 rounded">0.5-0.6</span>
                        <span class="px-2 py-0.5 bg-orange-200 text-orange-700 rounded">0.6-0.8</span>
                        <span class="px-2 py-0.5 bg-red-200 text-red-700 rounded">&gt;0.8</span>
                    </div>
                </div>
                <div class="overflow-x-auto">
                    <table class="w-full text-xs" id="corr-matrix"></table>
                </div>
                <div id="corr-warning"
                    class="hidden mt-4 p-3 bg-yellow-50 border border-yellow-200 rounded text-yellow-800 text-sm">
                    <i class="fa-solid fa-triangle-exclamation mr-2"></i> <strong>High Correlation Alert:</strong>
                    Some
                    positions have correlation &gt; 0.8, indicating concentrated risk.
                </div>
            </div>
        </div>

        <!-- TRADE IDEAS TAB -->
        <div id="tab-ideas" class="tab-content hidden">
            <div class="mw-card">
                <div class="flex justify-between items-center mb-6 border-b border-slate-100 pb-4">
                    <h3 class="font-bold text-lg text-slate-800"><i
                            class="fa-solid fa-magnifying-glass-chart text-purple-500 mr-2"></i>Recent Entry Signals
                    </h3>
                    <div class="flex items-center gap-4">
                        <label
                            class="flex items-center space-x-2 text-xs text-slate-600 cursor-pointer select-none bg-slate-50 px-3 py-1.5 rounded-full border hover:bg-slate-100 transition">
                            <input type="checkbox" id="show-bad-entries" class="accent-purple-500 h-3 w-3"
                                onchange="updateTradeIdeas(DATA.history[STATE.idx])">
                            <span>Show Bad Entries</span>
                        </label>
                        <span id="ideas-count"
                            class="text-xs bg-purple-50 text-purple-700 px-2 py-1 rounded border border-purple-200 font-mono"></span>
                    </div>
                </div>
                <p class="text-sm text-slate-500 mb-4">Click on a row to view the full trading setup details.</p>
                <div class="overflow-x-auto">
                    <table class="w-full text-left text-sm">
                        <thead class="bg-slate-50 text-slate-500 uppercase text-xs font-bold">
                            <tr>
                                <th class="px-4 py-3 cursor-pointer hover:bg-slate-100 transition-colors"
                                    onclick="toggleSort('ideas', 'Date')">Date <i
                                        class="fa-solid fa-sort ml-1 opacity-30"></i></th>
                                <th class="px-4 py-3 cursor-pointer hover:bg-slate-100 transition-colors"
                                    onclick="toggleSort('ideas', 'Symbol')">Symbol <i
                                        class="fa-solid fa-sort ml-1 opacity-30"></i></th>
                                <th class="px-4 py-3 text-right cursor-pointer hover:bg-slate-100 transition-colors"
                                    onclick="toggleSort('ideas', 'Price')">Entry <i
                                        class="fa-solid fa-sort ml-1 opacity-30"></i></th>
                                <th class="px-4 py-3 text-right cursor-pointer hover:bg-slate-100 transition-colors"
                                    onclick="toggleSort('ideas', 'Perf')">Last Price <i
                                        class="fa-solid fa-sort ml-1 opacity-30"></i></th>
                                <th class="px-4 py-3 text-right text-rose-500">Stop Loss</th>
                                <th class="px-4 py-3 text-right text-emerald-600">Take Profit</th>
                                <th class="px-4 py-3 text-center cursor-pointer hover:bg-slate-100 transition-colors"
                                    onclick="toggleSort('ideas', 'RR')">R:R <i
                                        class="fa-solid fa-sort ml-1 opacity-30"></i></th>
                            </tr>
                        </thead>
                        <tbody id="ideas-review-body" class="divide-y divide-slate-100"></tbody>
                    </table>
                </div>
            </div>
        </div>

        <!-- DRIFT & QUALITY TAB -->
        <div id="tab-drift" class="tab-content hidden">
            <!-- KPIs Section -->
            <div class="grid grid-cols-2 md:grid-cols-4 gap-4 mb-8">
                <div class="hero-stat">
                    <div class="text-xs uppercase font-bold text-slate-400 mb-1">Data Quality Score</div>
                    <div class="text-2xl font-black" id="drift-quality-score">--%</div>
                </div>
                <div class="hero-stat">
                    <div class="text-xs uppercase font-bold text-slate-400 mb-1">Price Gaps Detected</div>
                    <div class="text-2xl font-black text-orange-600" id="drift-gaps-count">--</div>
                </div>
                <div class="hero-stat">
                    <div class="text-xs uppercase font-bold text-slate-400 mb-1">Missing Data Points</div>
                    <div class="text-2xl font-black text-rose-600" id="drift-missing-count">--</div>
                </div>
                <div class="hero-stat">
                    <div class="text-xs uppercase font-bold text-slate-400 mb-1">Drift Alert Level</div>
                    <div class="text-2xl font-black text-purple-600" id="drift-alert-level">--</div>
                </div>
            </div>

            <!-- Main Drift Detection Cards -->
            <div class="grid md:grid-cols-2 gap-6 mb-8">
                <!-- Price Distribution Drift -->
                <div class="mw-card">
                    <h3 class="font-bold text-lg text-slate-800 mb-4 flex items-center gap-2">
                        <i class="fa-solid fa-chart-area text-blue-500"></i>
                        Return Distribution Drift
                        <span class="tooltip-wrapper">
                            <span class="info-icon">i</span>
                            <span class="tooltip-text">Compares recent return distribution vs historical baseline to
                                detect regime changes</span>
                        </span>
                    </h3>
                    <div class="h-64"><canvas id="drift-returns-chart"></canvas></div>
                    <div class="mt-4 grid grid-cols-2 gap-3">
                        <div class="p-3 bg-slate-50 rounded border">
                            <div class="text-xs text-slate-500 uppercase font-bold">KL Divergence</div>
                            <div class="text-lg font-black" id="drift-kl-value">--</div>
                            <div class="text-xs text-slate-400 mt-1">Threshold: 0.15</div>
                        </div>
                        <div class="p-3 bg-slate-50 rounded border">
                            <div class="text-xs text-slate-500 uppercase font-bold">PSI Score</div>
                            <div class="text-lg font-black" id="drift-psi-value">--</div>
                            <div class="text-xs text-slate-400 mt-1">Threshold: 0.25</div>
                        </div>
                    </div>
                </div>

                <!-- Prediction Quality -->
                <div class="mw-card">
                    <h3 class="font-bold text-lg text-slate-800 mb-4 flex items-center gap-2">
                        <i class="fa-solid fa-bullseye text-purple-500"></i>
                        Prediction Quality
                        <span class="tooltip-wrapper">
                            <span class="info-icon">i</span>
                            <span class="tooltip-text">Measures how well the strategy's predictions align with actual
                                outcomes over time</span>
                        </span>
                    </h3>
                    <div class="h-64"><canvas id="drift-prediction-chart"></canvas></div>
                    <div class="mt-4 grid grid-cols-3 gap-2">
                        <div class="p-2 bg-emerald-50 rounded border border-emerald-100 text-center">
                            <div class="text-xs text-emerald-600 uppercase font-bold">Accuracy</div>
                            <div class="text-lg font-black text-emerald-700" id="pred-accuracy">--%</div>
                        </div>
                        <div class="p-2 bg-blue-50 rounded border border-blue-100 text-center">
                            <div class="text-xs text-blue-600 uppercase font-bold">Precision</div>
                            <div class="text-lg font-black text-blue-700" id="pred-precision">--%</div>
                        </div>
                        <div class="p-2 bg-purple-50 rounded border border-purple-100 text-center">
                            <div class="text-xs text-purple-600 uppercase font-bold">F1 Score</div>
                            <div class="text-lg font-black text-purple-700" id="pred-f1">--%</div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Financial Impact Summary -->
            <div class="grid md:grid-cols-3 gap-6 mb-8">
                <div class="mw-card bg-gradient-to-br from-rose-50 to-white border-rose-200">
                    <h4 class="font-bold text-sm text-rose-800 mb-2 flex items-center gap-2">
                        <i class="fa-solid fa-money-bill-trend-up text-rose-600"></i>
                        Total Gap/Drift Losses
                    </h4>
                    <div class="text-3xl font-black text-rose-600" id="total-drift-loss-amount">--</div>
                    <div class="text-xs text-rose-500 font-bold mt-1" id="total-drift-loss-pct">-- of portfolio</div>
                </div>

                <div class="mw-card bg-gradient-to-br from-orange-50 to-white border-orange-200">
                    <h4 class="font-bold text-sm text-orange-800 mb-2 flex items-center gap-2">
                        <i class="fa-solid fa-chart-line-down text-orange-600"></i>
                        Stop Losses Hit by Gaps
                    </h4>
                    <div class="text-3xl font-black text-orange-600" id="sl-hit-by-gaps-count">--</div>
                    <div class="text-xs text-orange-500 font-bold mt-1" id="sl-hit-by-gaps-amount">-- lost</div>
                </div>

                <div class="mw-card bg-gradient-to-br from-purple-50 to-white border-purple-200">
                    <h4 class="font-bold text-sm text-purple-800 mb-2 flex items-center gap-2">
                        <i class="fa-solid fa-exclamation-triangle text-purple-600"></i>
                        Other Issues
                    </h4>
                    <div class="text-3xl font-black text-purple-600" id="other-issues-count">--</div>
                    <div class="text-xs text-purple-500 font-bold mt-1">Slippage, Low Liquidity, etc.</div>
                </div>
            </div>

            <!-- Price Gaps Detail Table -->
            <div class="mw-card mb-8">
                <div class="flex justify-between items-center mb-4">
                    <h3 class="font-bold text-lg text-slate-800 flex items-center gap-2">
                        <i class="fa-solid fa-chart-line text-orange-500"></i>
                        Price Gaps Analysis
                        <span class="tooltip-wrapper">
                            <span class="info-icon">i</span>
                            <span class="tooltip-text">Large price movements (>5%) that may indicate data quality issues
                                or unexpected market events affecting stop losses</span>
                        </span>
                    </h3>
                    <button onclick="clearGapsFilters()"
                        class="text-xs px-3 py-1.5 bg-slate-100 hover:bg-slate-200 text-slate-600 rounded-lg font-bold transition-colors">
                        <i class="fa-solid fa-filter-circle-xmark mr-1"></i>Clear Filters
                    </button>
                </div>
                <div class="overflow-x-auto max-h-96 overflow-y-auto">
                    <table class="w-full text-sm">
                        <thead class="bg-slate-50 text-slate-500 uppercase text-xs font-bold sticky top-0 z-10">
                            <tr>
                                <th class="px-4 py-3 text-left cursor-pointer hover:bg-slate-100"
                                    onclick="sortGapsTable('date')">
                                    Date <i class="fa-solid fa-sort ml-1 opacity-30"></i>
                                </th>
                                <th class="px-4 py-3 text-left cursor-pointer hover:bg-slate-100"
                                    onclick="sortGapsTable('symbol')">
                                    Symbol <i class="fa-solid fa-sort ml-1 opacity-30"></i>
                                </th>
                                <th class="px-4 py-3 text-right cursor-pointer hover:bg-slate-100"
                                    onclick="sortGapsTable('gapPct')">
                                    Gap % <i class="fa-solid fa-sort ml-1 opacity-30"></i>
                                </th>
                                <th class="px-4 py-3 text-right cursor-pointer hover:bg-slate-100"
                                    onclick="sortGapsTable('priceBefore')">
                                    Price Before <i class="fa-solid fa-sort ml-1 opacity-30"></i>
                                </th>
                                <th class="px-4 py-3 text-right cursor-pointer hover:bg-slate-100"
                                    onclick="sortGapsTable('priceAfter')">
                                    Price After <i class="fa-solid fa-sort ml-1 opacity-30"></i>
                                </th>
                                <th class="px-4 py-3 text-center">SL Hit?</th>
                                <th class="px-4 py-3 text-right cursor-pointer hover:bg-slate-100"
                                    onclick="sortGapsTable('impact')">
                                    Financial Impact <i class="fa-solid fa-sort ml-1 opacity-30"></i>
                                </th>
                            </tr>
                            <tr class="bg-white border-b border-slate-200">
                                <th class="px-2 py-2">
                                    <input type="text" id="filter-gaps-date" placeholder="YYYY-MM-DD"
                                        class="w-full px-2 py-1 text-xs border border-slate-200 rounded focus:outline-none focus:ring-2 focus:ring-orange-500"
                                        oninput="filterGapsTable()">
                                </th>
                                <th class="px-2 py-2">
                                    <input type="text" id="filter-gaps-symbol" placeholder="Symbol..."
                                        class="w-full px-2 py-1 text-xs border border-slate-200 rounded focus:outline-none focus:ring-2 focus:ring-orange-500"
                                        oninput="filterGapsTable()">
                                </th>
                                <th class="px-2 py-2">
                                    <input type="number" id="filter-gaps-gapPct" placeholder="Min %"
                                        class="w-full px-2 py-1 text-xs border border-slate-200 rounded text-center focus:outline-none focus:ring-2 focus:ring-orange-500"
                                        oninput="filterGapsTable()" min="0" step="0.1">
                                </th>
                                <th class="px-2 py-2"></th>
                                <th class="px-2 py-2"></th>
                                <th class="px-2 py-2">
                                    <select id="filter-gaps-slHit"
                                        class="w-full px-2 py-1 text-xs border border-slate-200 rounded focus:outline-none focus:ring-2 focus:ring-orange-500"
                                        onchange="filterGapsTable()">
                                        <option value="">All</option>
                                        <option value="YES">Yes</option>
                                        <option value="NO">No</option>
                                    </select>
                                </th>
                                <th class="px-2 py-2">
                                    <input type="text" id="filter-gaps-impact" placeholder="< -1000"
                                        class="w-full px-2 py-1 text-xs border border-slate-200 rounded text-center focus:outline-none focus:ring-2 focus:ring-orange-500"
                                        oninput="filterGapsTable()">
                                </th>
                            </tr>
                        </thead>
                        <tbody id="gaps-table-body" class="divide-y divide-slate-100">
                            <!-- JS populated -->
                        </tbody>
                    </table>
                </div>
            </div>

            <!-- Other Data Quality Issues -->
            <div class="grid md:grid-cols-2 gap-6 mb-8">
                <!-- Missing Data -->
                <div class="mw-card">
                    <h3 class="font-bold text-lg text-slate-800 mb-4 flex items-center gap-2">
                        <i class="fa-solid fa-calendar-xmark text-rose-500"></i>
                        Missing Data Periods
                    </h3>
                    <div id="missing-list" class="space-y-2 max-h-64 overflow-y-auto custom-scrollbar">
                        <!-- JS populated -->
                    </div>
                </div>

                <!-- Other Prediction Issues -->
                <div class="mw-card">
                    <h3 class="font-bold text-lg text-slate-800 mb-4 flex items-center gap-2">
                        <i class="fa-solid fa-bugs text-purple-500"></i>
                        Other Prediction Issues
                    </h3>
                    <div id="other-issues-list" class="space-y-2 max-h-64 overflow-y-auto custom-scrollbar">
                        <!-- JS populated -->
                    </div>
                </div>
            </div>

            <!-- Volatility Drift -->
            <div class="mw-card mb-8">
                <h3 class="font-bold text-lg text-slate-800 mb-4 flex items-center gap-2">
                    <i class="fa-solid fa-wave-square text-indigo-500"></i>
                    Volatility Regime Detection
                    <span class="tooltip-wrapper">
                        <span class="info-icon">i</span>
                        <span class="tooltip-text">Tracks rolling volatility to detect regime changes that may affect
                            strategy performance</span>
                    </span>
                </h3>
                <div class="h-80"><canvas id="drift-volatility-chart"></canvas></div>
                <div class="mt-4 grid grid-cols-4 gap-3">
                    <div class="p-3 bg-slate-50 rounded border text-center">
                        <div class="text-xs text-slate-500 uppercase font-bold">Current Vol</div>
                        <div class="text-lg font-black" id="vol-current">--%</div>
                    </div>
                    <div class="p-3 bg-slate-50 rounded border text-center">
                        <div class="text-xs text-slate-500 uppercase font-bold">Avg Vol</div>
                        <div class="text-lg font-black" id="vol-avg">--%</div>
                    </div>
                    <div class="p-3 bg-slate-50 rounded border text-center">
                        <div class="text-xs text-slate-500 uppercase font-bold">Vol Ratio</div>
                        <div class="text-lg font-black" id="vol-ratio">--</div>
                    </div>
                    <div class="p-3 rounded border text-center" id="vol-regime-box">
                        <div class="text-xs uppercase font-bold">Regime</div>
                        <div class="text-lg font-black" id="vol-regime">NORMAL</div>
                    </div>
                </div>
            </div>

            <!-- Symbol-level Drift Heatmap -->
            <div class="mw-card">
                <div class="flex justify-between items-center mb-4">
                    <h3 class="font-bold text-lg text-slate-800 flex items-center gap-2">
                        <i class="fa-solid fa-table-cells text-teal-500"></i>
                        Symbol-Level Drift Analysis
                    </h3>
                    <button onclick="clearDriftFilters()"
                        class="text-xs px-3 py-1.5 bg-slate-100 hover:bg-slate-200 text-slate-600 rounded-lg font-bold transition-colors">
                        <i class="fa-solid fa-filter-circle-xmark mr-1"></i>Clear Filters
                    </button>
                </div>
                <div class="overflow-x-auto">
                    <table class="w-full text-sm" id="symbol-drift-table">
                        <thead class="bg-slate-50 text-slate-500 uppercase text-xs font-bold">
                            <tr>
                                <th class="px-4 py-3 text-left cursor-pointer hover:bg-slate-100 transition-colors"
                                    onclick="sortDriftTable('symbol')">
                                    Symbol <i class="fa-solid fa-sort ml-1 opacity-30"></i>
                                </th>
                                <th class="px-4 py-3 text-center cursor-pointer hover:bg-slate-100 transition-colors"
                                    onclick="sortDriftTable('returnsDrift')">
                                    Returns Drift <i class="fa-solid fa-sort ml-1 opacity-30"></i>
                                </th>
                                <th class="px-4 py-3 text-center cursor-pointer hover:bg-slate-100 transition-colors"
                                    onclick="sortDriftTable('volDrift')">
                                    Vol Drift <i class="fa-solid fa-sort ml-1 opacity-30"></i>
                                </th>
                                <th class="px-4 py-3 text-center cursor-pointer hover:bg-slate-100 transition-colors"
                                    onclick="sortDriftTable('gaps')">
                                    Price Gaps <i class="fa-solid fa-sort ml-1 opacity-30"></i>
                                </th>
                                <th class="px-4 py-3 text-center cursor-pointer hover:bg-slate-100 transition-colors"
                                    onclick="sortDriftTable('missing')">
                                    Missing Days <i class="fa-solid fa-sort ml-1 opacity-30"></i>
                                </th>
                                <th class="px-4 py-3 text-center cursor-pointer hover:bg-slate-100 transition-colors"
                                    onclick="sortDriftTable('healthScore')">
                                    Health Score <i class="fa-solid fa-sort ml-1 opacity-30"></i>
                                </th>
                                <th class="px-4 py-3 text-center cursor-pointer hover:bg-slate-100 transition-colors"
                                    onclick="sortDriftTable('status')">
                                    Status <i class="fa-solid fa-sort ml-1 opacity-30"></i>
                                </th>
                            </tr>
                            <tr class="bg-white border-b border-slate-200">
                                <th class="px-2 py-2">
                                    <input type="text" id="filter-drift-symbol" placeholder="Filter..."
                                        class="w-full px-2 py-1 text-xs border border-slate-200 rounded focus:outline-none focus:ring-2 focus:ring-teal-500 focus:border-transparent"
                                        oninput="filterDriftTable()">
                                </th>
                                <th class="px-2 py-2">
                                    <input type="text" id="filter-drift-returnsDrift" placeholder="< 0.15"
                                        class="w-full px-2 py-1 text-xs border border-slate-200 rounded text-center focus:outline-none focus:ring-2 focus:ring-teal-500 focus:border-transparent"
                                        oninput="filterDriftTable()">
                                </th>
                                <th class="px-2 py-2">
                                    <input type="text" id="filter-drift-volDrift" placeholder="< 0.25"
                                        class="w-full px-2 py-1 text-xs border border-slate-200 rounded text-center focus:outline-none focus:ring-2 focus:ring-teal-500 focus:border-transparent"
                                        oninput="filterDriftTable()">
                                </th>
                                <th class="px-2 py-2">
                                    <input type="text" id="filter-drift-gaps" placeholder="> 0"
                                        class="w-full px-2 py-1 text-xs border border-slate-200 rounded text-center focus:outline-none focus:ring-2 focus:ring-teal-500 focus:border-transparent"
                                        oninput="filterDriftTable()">
                                </th>
                                <th class="px-2 py-2">
                                    <input type="text" id="filter-drift-missing" placeholder="> 0"
                                        class="w-full px-2 py-1 text-xs border border-slate-200 rounded text-center focus:outline-none focus:ring-2 focus:ring-teal-500 focus:border-transparent"
                                        oninput="filterDriftTable()">
                                </th>
                                <th class="px-2 py-2">
                                    <input type="text" id="filter-drift-healthScore" placeholder="< 70"
                                        class="w-full px-2 py-1 text-xs border border-slate-200 rounded text-center focus:outline-none focus:ring-2 focus:ring-teal-500 focus:border-transparent"
                                        oninput="filterDriftTable()">
                                </th>
                                <th class="px-2 py-2">
                                    <select id="filter-drift-status"
                                        class="w-full px-2 py-1 text-xs border border-slate-200 rounded focus:outline-none focus:ring-2 focus:ring-teal-500 focus:border-transparent"
                                        onchange="filterDriftTable()">
                                        <option value="">All</option>
                                        <option value="HEALTHY">HEALTHY</option>
                                        <option value="WATCH">WATCH</option>
                                        <option value="WARNING">WARNING</option>
                                        <option value="CRITICAL">CRITICAL</option>
                                    </select>
                                </th>
                            </tr>
                        </thead>
                        <tbody id="symbol-drift-body" class="divide-y divide-slate-100">
                            <!-- JS populated -->
                        </tbody>
                    </table>
                </div>
            </div>
        </div>

        <!-- LOGS -->
        <div id="tab-logs" class="tab-content hidden">
            <div class="mw-card mb-6">
                <div class="flex justify-between items-center mb-4">
                    <h3 class="font-bold text-lg">Trade Journal</h3>
                    <div class="flex gap-2 bg-slate-100 p-1 rounded">
                        <button id="btn-flat" class="px-3 py-1 text-xs rounded font-bold transition"
                            onclick="setJournalMode('flat')">Flat</button>
                        <button id="btn-grp" class="px-3 py-1 text-xs rounded font-bold transition"
                            onclick="setJournalMode('grouped')">Grouped</button>
                        <button id="btn-cal" class="px-3 py-1 text-xs rounded font-bold transition"
                            onclick="setJournalMode('calendar')">Calendar</button>
                        <button id="btn-acc" class="px-3 py-1 text-xs rounded font-bold transition"
                            onclick="setJournalMode('accounting')">Accounting</button>
                    </div>
                </div>

                <!-- Flat/Grouped View -->
                <div id="journal-list-view" class="overflow-x-auto overflow-y-auto">
                    <table class="w-full text-sm" id="journal-table"></table>
                </div>

                <!-- Calendar View -->
                <div id="journal-calendar-view" class="hidden">
                    <div class="flex justify-between items-center mb-4">
                        <div class="flex items-center gap-2 text-xs">
                            <span class="px-2 py-1 bg-emerald-100 text-emerald-700 rounded">Profit Day</span>
                            <span class="px-2 py-1 bg-rose-100 text-rose-700 rounded">Loss Day</span>
                            <span class="px-2 py-1 bg-yellow-100 text-yellow-700 rounded">Mixed</span>
                        </div>
                        <div class="flex items-center gap-2">
                            <button onclick="changeCalYear(-1)"
                                class="px-3 py-1 bg-slate-100 rounded hover:bg-slate-200 transition text-sm font-bold text-slate-600"><i
                                    class="fa-solid fa-chevron-left"></i></button>
                            <span id="cal-month-label" class="font-bold text-slate-700 w-32 text-center"></span>
                            <button onclick="changeCalYear(1)"
                                class="px-3 py-1 bg-slate-100 rounded hover:bg-slate-200 transition text-sm font-bold text-slate-600"><i
                                    class="fa-solid fa-chevron-right"></i></button>
                        </div>
                    </div>
                    <div id="calendar-grid" class="grid grid-cols-7 gap-1 mb-6"></div>
                    <div id="calendar-day-detail" class="hidden p-4 bg-slate-50 rounded-lg border border-slate-200">
                        <h4 id="cal-detail-date" class="font-bold text-slate-800 mb-3"></h4>
                        <div id="cal-detail-trades" class="space-y-2"></div>
                    </div>
                </div>

                <!-- Accounting View -->
                <div id="journal-accounting-view" class="hidden overflow-x-auto">
                    <div class="flex justify-between items-center mb-6">
                        <div class="flex items-center gap-3">
                            <h3 class="text-lg font-black text-slate-800">Financial Snapshot</h3>
                            <span class="px-2 py-0.5 bg-slate-100 text-slate-500 rounded text-[10px] font-mono"
                                id="acc-date">--</span>
                        </div>
                    </div>

                    <div class="grid grid-cols-1 md:grid-cols-4 gap-4 mb-8">
                        <div class="p-4 bg-slate-50 rounded-lg border border-slate-100">
                            <div class="text-[10px] uppercase font-bold text-slate-400 mb-1">Total Equity</div>
                            <div class="text-xl font-black text-slate-800" id="acc-total">--</div>
                        </div>
                        <div class="p-4 bg-slate-50 rounded-lg border border-slate-100">
                            <div class="text-[10px] uppercase font-bold text-slate-400 mb-1">Available Cash</div>
                            <div class="text-xl font-black text-slate-600" id="acc-cash">--</div>
                        </div>
                        <div class="p-4 bg-emerald-50 rounded-lg border border-emerald-100">
                            <div class="text-[10px] uppercase font-bold text-emerald-600 mb-1">Realized PnL</div>
                            <div class="text-xl font-black text-emerald-700" id="acc-realized">--</div>
                        </div>
                        <div class="p-4 bg-blue-50 rounded-lg border border-blue-100">
                            <div class="text-[10px] uppercase font-bold text-blue-600 mb-1">Unrealized PnL</div>
                            <div class="text-xl font-black text-blue-700" id="acc-unrealized">--</div>
                        </div>
                    </div>

                    <div class="mb-8 p-1">
                        <h4 class="text-xs font-bold text-slate-500 uppercase mb-4 flex items-center gap-2">
                            <i class="fa-solid fa-briefcase text-blue-500"></i> Committed Positions
                        </h4>
                        <div class="overflow-hidden border border-slate-100 rounded-xl">
                            <table class="w-full text-sm text-left">
                                <thead class="bg-slate-50 text-[10px] uppercase font-bold text-slate-400">
                                    <tr>
                                        <th class="px-4 py-3 cursor-pointer hover:bg-slate-100"
                                            onclick="toggleSort('acc_pos', 'symbol')">Symbol <i
                                                class="fa-solid fa-sort ml-1 opacity-30"></i></th>
                                        <th class="px-4 py-3 text-right cursor-pointer hover:bg-slate-100"
                                            onclick="toggleSort('acc_pos', 'shares')">Qty <i
                                                class="fa-solid fa-sort ml-1 opacity-30"></i></th>
                                        <th class="px-4 py-3 text-right cursor-pointer hover:bg-slate-100"
                                            onclick="toggleSort('acc_pos', 'entry_date')">Entry Date <i
                                                class="fa-solid fa-sort ml-1 opacity-30"></i></th>
                                        <th class="px-4 py-3 text-right cursor-pointer hover:bg-slate-100"
                                            onclick="toggleSort('acc_pos', 'avg_cost')">Avg Price <i
                                                class="fa-solid fa-sort ml-1 opacity-30"></i></th>
                                        <th class="px-4 py-3 text-right cursor-pointer hover:bg-slate-100"
                                            onclick="toggleSort('acc_pos', 'current_price')">Market Price <i
                                                class="fa-solid fa-sort ml-1 opacity-30"></i></th>
                                        <th class="px-4 py-3 text-right cursor-pointer hover:bg-slate-100"
                                            onclick="toggleSort('acc_pos', 'value')">Value (Base) <i
                                                class="fa-solid fa-sort ml-1 opacity-30"></i></th>
                                        <th class="px-4 py-3 text-right cursor-pointer hover:bg-slate-100"
                                            onclick="toggleSort('acc_pos', 'unrealized_pnl')">PnL <i
                                                class="fa-solid fa-sort ml-1 opacity-30"></i></th>
                                        <th class="px-4 py-3 text-right cursor-pointer hover:bg-slate-100"
                                            onclick="toggleSort('acc_pos', 'weight')">Weight <i
                                                class="fa-solid fa-sort ml-1 opacity-30"></i></th>
                                    </tr>
                                </thead>
                                <tbody id="acc-positions-body" class="divide-y divide-slate-100"></tbody>
                            </table>
                        </div>
                    </div>

                    <div class="p-1">
                        <h4 class="text-xs font-bold text-slate-500 uppercase mb-4 flex items-center gap-2">
                            <i class="fa-solid fa-clock-rotate-left text-orange-500"></i> Pending Orders
                        </h4>
                        <div class="overflow-hidden border border-slate-100 rounded-xl">
                            <table class="w-full text-sm text-left">
                                <thead class="bg-slate-50 text-[10px] uppercase font-bold text-slate-400">
                                    <tr>
                                        <th class="px-4 py-3">Symbol</th>
                                        <th class="px-4 py-3">Order Date</th>
                                        <th class="px-4 py-3">Type</th>
                                        <th class="px-4 py-3 text-right">Qty</th>
                                        <th class="px-4 py-3 text-right">Lmt/Stop Price</th>
                                        <th class="px-4 py-3">Status</th>
                                    </tr>
                                </thead>
                                <tbody id="acc-pending-body" class="divide-y divide-slate-100"></tbody>
                            </table>
                        </div>
                    </div>
                </div>
            </div>
        </div>


    </main>

    <!-- FOOTER -->
    <footer
        style="text-align:center; padding:3rem; color:#94a3b8; font-size:0.9rem; background:#f1f5f9; margin-top:4rem; border-top:1px solid #e2e8f0;">
        <div class="max-w-7xl mx-auto px-6">
            <p style="margin-bottom:1rem; font-weight:600; color:#64748b;">&copy; 2025 Market Watch.</p>
            <p style="font-size:0.8rem; max-width:600px; margin:0 auto; line-height:1.6;">
                Disclaimer: This report is for educational purposes only. Past performance is not indicative of future
                results.
                Investing involves risk.
            </p>
            <p class="text-xs text-slate-300 mt-2">Generated on 2026-01-11 21:41:19 UTC.</p>
        </div>
    </footer>

    <script>
        window.DEBUG_MODE = "false" === "true";
        const PERIODS_LIST_JSON = [{"id": "1y", "label": "1Y"}];

        let DATA, TRADES, BENCH, FX_HISTORY, RECOMMENDATIONS;
        let CURRENT_PERIOD = "1y";
        let PORTFOLIO_ID = "unknown";

        async function initViewer() {
            const params = new URLSearchParams(window.location.search);
            const id = params.get('id');
            const period = params.get('period') || '1y';
            const date = params.get('date') || '2026-01-11';
            
            if(!id) {
                document.body.innerHTML = '<div class="p-10 text-center text-rose-500 font-bold">No Portfolio ID specified.</div>';
                return;
            }
            
            CURRENT_PERIOD = period;
            PORTFOLIO_ID = id;

            try {
                // Fetch JSON from Date/Period path with cache busting
                const ts = new Date().getTime();
                const url = `${date}/${period}/web/${id}.json?t=${ts}`;
                console.log("Fetching report:", url);
                
                const resp = await fetch(url);
                let json = {};
                if(!resp.ok) {
                    if (resp.status === 404) {
                        console.warn("Report 404, using empty mock.");
                        const label = id.charAt(0).toUpperCase() + id.slice(1);
                        json = { data: null, trades: [], benchmarks: {}, fx: {}, meta: { name: label, initial_capital: 100000 } };
                    } else {
                        throw new Error("Report data not found (" + resp.status + ")");
                    }
                } else {
                    json = await resp.json();
                    window.BASE_URL = url.substring(0, url.lastIndexOf('/') + 1);
                }
                
                // Fetch History Chunks (Linked List)
                // Start with the first chunk
                // We expect history split into parts, or a single file pointing to next
                // But simplified: we check if base history file has 'next' field? 
                // Currently `json` is stats/metadata. 
                // We assume there is a `_history.json` or `_history_1.json`.
                // Let's assume `_history_1.json` is the entry point if we use chunking.
                // Or we fetch `_history.json` and if it has {items: [], next: ...} we handle it.
                // If it is just [], we handle that too.
                
                const historyBaseUrl = url.replace(".json", "_history.json");
                let historyAccumulator = [];
                let nextChunkUrl = historyBaseUrl;
                
                console.log("Loading history chain...");
                
                try {
                    while(nextChunkUrl) {
                        const hResp = await fetch(nextChunkUrl);
                        if(!hResp.ok) {
                            if(historyAccumulator.length === 0) console.warn("History file not found: " + nextChunkUrl);
                            break; 
                        }
                        
                        const hData = await hResp.json();
                        
                        if(Array.isArray(hData)) {
                             // legacy/simple mode: just an array, no next
                             historyAccumulator = historyAccumulator.concat(hData);
                             nextChunkUrl = null;
                        } else if(hData.items) {
                             // chunked mode
                             historyAccumulator = historyAccumulator.concat(hData.items);
                             // resolve relative next url
                             if(hData.next) {
                                 // Resolve relative path
                                 const lastSlash = nextChunkUrl.lastIndexOf('/');
                                 if (lastSlash !== -1) {
                                     nextChunkUrl = nextChunkUrl.substring(0, lastSlash + 1) + hData.next;
                                 } else {
                                     nextChunkUrl = hData.next;
                                 }
                             } else {
                                 nextChunkUrl = null;
                             }
                        } else {
                             // unexpected format
                             console.warn("Unknown history format");
                             nextChunkUrl = null;
                        }
                    }
                    
                    if(!json.data) json.data = {};
                    json.data.history = historyAccumulator;
                    console.log("History loaded. Total entries:", historyAccumulator.length);
                    
                } catch(e) { console.warn("Failed to fetch history chain", e); }
                
                window.DATA = json.data || json;
                DATA = window.DATA;

                // Store trades in DATA for drift analysis
                TRADES = json.trades || [];
                DATA.trades = TRADES;
                console.log('âœ… Trades loaded:', TRADES.length);

                // 1. Determine Correct Base Currency
                let baseC = 'EUR';
                if (DATA.currency) baseC = DATA.currency;
                else if (DATA.meta && DATA.meta.currency) baseC = DATA.meta.currency;
                else if (DATA.region === 'HK') baseC = 'HKD';
                
                // 2. Initial FX Setup (Merge embedded + Fetch Source)
                if(!window.FX_HISTORY) window.FX_HISTORY = json.fx || {};
            // Init FX Helpers
                
                const fetchFX = async (curr) => {
                    if(!curr || curr === 'EUR') return;
                    if(window.FX_HISTORY[curr] && Object.keys(window.FX_HISTORY[curr]).length > 0) return;
                    try {
                        // FX files are at root (output/fx-*.json), served relative to report.html
                        const fxUrl = `fx-${curr.toLowerCase()}.json`;
                        console.log(`Fetching FX: ${fxUrl}`);
                        const r = await fetch(fxUrl);
                        if(r.ok) {
                            const d = await r.json();
                            Object.assign(window.FX_HISTORY, d);
                            // Update Helper Keys
                            if(!window.FX_KEYS) window.FX_KEYS = {};
                            window.FX_KEYS[curr] = Object.keys(d[curr]).sort();
                        }
                    } catch(e) { console.warn("FX fetch fail", curr); }
                };
                
                // Fetch Source Currency FX immediately
                await fetchFX(baseC);
                
                // 3. Sync State and Override Selector
                if (typeof STATE !== 'undefined') {
                     STATE.currency = baseC;
                     const sel = document.getElementById('currency-selector');
                     if(sel) {
                         sel.value = baseC;
                     }
                }

                // 4. Override setGlobalCurrency for Lazy Loading
                const originalSetGlobalCurrency = window.setGlobalCurrency;
                window.setGlobalCurrency = async function(curr) {
                    await fetchFX(curr);
                    if(originalSetGlobalCurrency) originalSetGlobalCurrency(curr);
                };

                // 5. Override getFX (Robust)
                window.getFX = function(date, target) {
                    const d = window.DATA || DATA;
                    let s = 'EUR';
                    if (d) {
                         if (d.currency) s = d.currency;
                         else if (d.meta && d.meta.currency) s = d.meta.currency;
                         else if (d.region === 'HK') s = 'HKD';
                    }
                    const sourceCurr = s;
                    if (target === sourceCurr) return 1.0;

                    const _calcRate = (c) => {
                        try {
                            if (!c || c === 'EUR') return 1.0;
                            const dKey = (typeof date === 'string') ? date.split('T')[0] : date;
                            
                            // Check existence
                            if (!window.FX_HISTORY) return 1.0;
                            const ratesMap = window.FX_HISTORY;
                            if (!ratesMap[c]) return 1.0;
                            
                            const entries = ratesMap[c];
                            if (!entries) return 1.0;

                            // Checks keys existence
                            if (!window.FX_KEYS || !window.FX_KEYS[c] || !Array.isArray(window.FX_KEYS[c])) {
                                // Fallback to simple lookup if keys missing
                                if (entries[dKey] && entries[dKey] > 0) return (1.0 / entries[dKey]);
                                return 1.0;
                            }
                            
                            const dates = window.FX_KEYS[c]; 
                            if (dates.length === 0) return 1.0;

                            // 1. Exact Match
                            if (entries[dKey] && entries[dKey] > 0) return (1.0 / entries[dKey]);

                            // 2. Nearest Past Date (Fallback)
                            let bestDate = null;
                            for (let i = dates.length - 1; i >= 0; i--) { 
                                if (dates[i] <= dKey) { 
                                    bestDate = dates[i];
                                    break;
                                }
                            }
                            
                            if (bestDate && entries[bestDate] > 0) {
                                return (1.0 / entries[bestDate]); 
                            } 
                            
                            // 3. Ultimate Fallback
                            if (dates.length > 0) {
                                const safestFallbackDate = dates[dates.length - 1]; 
                                if (entries[safestFallbackDate] > 0) {
                                    return (1.0 / entries[safestFallbackDate]);
                                }
                            }
                            return 1.0;
                        } catch(e) {
                            console.warn("FX Error:", e);
                            return 1.0;
                        }
                    };
                    return _calcRate(target) / _calcRate(sourceCurr);
                };
                if (!DATA || !DATA.history || DATA.history.length === 0) {
                    console.warn("History empty. Mocking initial state.");
                    // Create dummy structure if DATA missing
                    if(!DATA) DATA = { history: [] };
                    
                    DATA.history = [{
                        date: new Date().toISOString().split('T')[0],
                        equity: (json.meta ? json.meta.initial_capital : 100000) || 100000,
                        cash: (json.meta ? json.meta.initial_capital : 100000) || 100000,
                        positions: []
                    }];
                }
                TRADES = json.trade_logs || json.trades || [];
                RECOMMENDATIONS = json.recommendations || [];
                BENCH = json.benchmarks;
                
                // Fetch Centralized FX from root (universal across periods)
                
                // Fetch Centralized FX removed in favor of lazy load (see fetchFX)
                // Initialize FX_HISTORY fallback if not set
                if(!window.FX_HISTORY) window.FX_HISTORY = json.fx || {}; 
                
                // Update Title
                document.title = json.meta.name + " | Market Watch";
                const titleSpan = document.querySelector('nav span.text-lg');
                if(titleSpan) titleSpan.innerText = json.meta.name;
                
                // Start Logic
                init();
                
            } catch(e) {
                console.error(e);
                 document.body.innerHTML = `<div class="p-10 text-center text-rose-500 font-bold text-lg">Failed to load report.<br><span class="text-sm font-normal text-slate-500 font-mono mt-2 inline-block bg-slate-100 p-2 rounded border border-slate-200">${e.message}</span></div>`;
            }
        }
    

        async function loadReportData() {
            const params = new URLSearchParams(window.location.search);
            const id = params.get('id');
            const period = params.get('period');

            if (!id) {
                console.warn("No ID provided for report.");
                return;
            }
            PORTFOLIO_ID = id;
            if (period) CURRENT_PERIOD = period;

            // Try paths: 1. Current dir, 2. web/ subdir
            const paths = [`${id}.json`, `web/${id}.json`];
            let jsonData = null;
            let baseUrl = "";

            for (const p of paths) {
                try {
                    const resp = await fetch(p);
                    if (resp.ok) {
                        jsonData = await resp.json();
                        const lastSlash = p.lastIndexOf('/');
                        if (lastSlash !== -1) baseUrl = p.substring(0, lastSlash + 1);
                        break;
                    }
                } catch (e) { }
            }

            if (!jsonData) {
                console.error("Could not load report JSON for", id);
                document.body.innerHTML = `<div class="p-10 text-red-500 font-bold">Error: Report data not found for ID: ${id}</div>`;
                return;
            }

            // Assign Globals
            DATA = jsonData.data || {};
            TRADES = jsonData.trades || [];
            DATA.trades = TRADES; // Also store in DATA for drift analysis

            // Make globally accessible for debugging
            window.DEBUG_DATA = DATA;
            window.DEBUG_TRADES = TRADES;

            if (window.DEBUG_MODE) {
                console.log('ðŸ” DATA LOADING DEBUG:');
                console.log('  - jsonData.trades exists?', !!jsonData.trades);
                console.log('  - jsonData.trades length:', jsonData.trades?.length || 0);
                console.log('  - TRADES assigned length:', TRADES.length);
                console.log('  - DATA.trades assigned length:', DATA.trades?.length || 0);
                console.log('  - First trade sample:', TRADES[0]);
                console.log('  - window.DEBUG_TRADES length:', window.DEBUG_TRADES?.length);
                console.log('  - window.DEBUG_DATA.trades length:', window.DEBUG_DATA.trades?.length);
            }
            BENCH = jsonData.benchmarks || {};
            FX_HISTORY = jsonData.fx || {};

            // Load History (Chunked)
            // Load History (Chunked)
            try {
                // NEW: Parallel Loading if chunks list is provided in metadata
                if (jsonData.history_chunks && jsonData.history_chunks.length > 0) {
                    console.log(`ðŸš€ Parallel loading ${jsonData.history_chunks.length} history chunks...`);
                    const chunkPromises = jsonData.history_chunks.map(filename =>
                        fetch(baseUrl + filename).then(r => r.json()).then(j => j.items || j)
                    );

                    const allChunks = await Promise.all(chunkPromises);
                    DATA.history = allChunks.flat();
                    console.log(`âœ… Loaded ${DATA.history.length} history points (Parallel)`);

                } else {
                    // LEGACY: Sequential Linked List Logic
                    const historyPath = baseUrl + `${id}_history.json`;
                    const hResp = await fetch(historyPath);
                    if (hResp.ok) {
                        const hJson = await hResp.json();
                        let items = hJson.items || hJson;
                        DATA.history = items;

                        let nextChunk = hJson.next;
                        while (nextChunk) {
                            console.log("Loading next chunk:", nextChunk);
                            const ncResp = await fetch(baseUrl + nextChunk);
                            if (ncResp.ok) {
                                const ncJson = await ncResp.json();
                                DATA.history = DATA.history.concat(ncJson.items || ncJson);
                                nextChunk = ncJson.next;
                            } else {
                                break;
                            }
                        }
                    } else {
                        console.warn("History file not found:", historyPath);
                    }
                }
            } catch (e) {
                console.warn("History fetch error:", e);
            }

            // Render
            init();

            // Set Currency from Params
            const c = params.get('currency');
            if (c) {
                STATE.currency = c;
                const sel = document.getElementById('currency-selector');
                if (sel) sel.value = c;
            }
            if (typeof setGlobalCurrency === 'function') {
                setGlobalCurrency(STATE.currency);
            }
        }

        // Start Loading
        document.addEventListener('DOMContentLoaded', initViewer);

        let STATE = {
            idx: 0,
            currency: 'EUR',
            journalMode: 'flat',
            posCurrencyMode: 'GLOBAL',
            sort: {
                pos: { col: 'value', dir: -1 },
                journal: { col: 'Date', dir: -1 },
                ideas: { col: 'Date', dir: -1 },
                orders: { col: 'symbol', dir: 1 },
                acc_pos: { col: 'value', dir: -1 }
            }
        };

        function toggleSort(tableId, column) {
            const s = STATE.sort[tableId];
            if (s.col === column) {
                s.dir *= -1;
            } else {
                s.col = column;
                s.dir = 1;
            }

            // Re-render
            const snap = DATA.history[STATE.idx];
            if (snap) {
                const fx = getFX(snap.date, STATE.currency);
                if (tableId === 'pos') updatePositions(snap, fx);
                if (tableId === 'journal') updateLogs(snap.date, fx);
                if (tableId === 'ideas') updateTradeIdeas(snap);
                if (tableId === 'orders') updateOrders(snap, fx);
                if (tableId === 'acc_pos') updateAccounting(snap, fx);
            }
        }

        const el = (id) => document.getElementById(id);
        const fmtMoney = (v, c = STATE.currency) => {
            const syms = { 'EUR': 'â‚¬', 'USD': '$', 'CHF': 'CHF', 'JPY': 'Â¥', 'CNY': 'Â¥', 'BTC': 'â‚¿', 'GOLD': 'oz' };
            const s = syms[c] || c;
            if (c === 'BTC') return 'â‚¿ ' + v.toFixed(6);
            if (c === 'GOLD') return v.toFixed(2) + ' oz';
            return new Intl.NumberFormat('en-US', { style: 'currency', currency: (c === 'GOLD' || c === 'BTC') ? 'USD' : c }).format(v).replace('USD', '$');
        };
        const fmtPct = (v) => (v * 100).toFixed(2) + '%';
        const fmtNum = (v) => new Intl.NumberFormat('en-US').format(v);
        let charts = {};

        function getFX(date, target) {
            console.log("FX Logic Loaded");
            // v5-safe
            if (!date || !target) return 1.0;
            const sourceCurr = (DATA.currency) ? DATA.currency : ((DATA.region === 'HK') ? 'HKD' : 'USD');
            if (target === sourceCurr) return 1.0;

            const dKey = (typeof date === 'string') ? date.split('T')[0] : date;

            const _calcRate = (c) => {
                try {
                    if (!c || c === 'EUR') return 1.0;
                    const ratesMap = FX_HISTORY;
                    if (ratesMap && ratesMap[c]) {
                        const entries = ratesMap[c];
                        if (!entries) return 1.0;

                        // Try exact, then dKey
                        const rate = entries[date] || entries[dKey];
                        if (rate !== undefined && rate !== null) return (rate > 0) ? (1.0 / rate) : 1.0;

                        // Keys fallback
                        if (window.FX_KEYS && window.FX_KEYS[c] && Array.isArray(window.FX_KEYS[c])) {
                            const dates = window.FX_KEYS[c];
                            if (dates.length === 0) return 1.0;

                            let bestDate = null;
                            // Linear search from end (optimize later if needed)
                            for (let i = dates.length - 1; i >= 0; i--) {
                                if (dates[i] <= dKey) {
                                    bestDate = dates[i];
                                    break;
                                }
                            }

                            if (bestDate && entries[bestDate]) return (entries[bestDate] > 0) ? (1.0 / entries[bestDate]) : 1.0;
                            // Fallback to first available if no past data (e.g. future date requested before history starts? Unlikely for FX).
                            // Or if we are requesting a date BEFORE the first FX record.
                            // Defaulting to first record is safer than 1.0 for major pairs.
                            if (dates.length > 0 && entries[dates[0]]) return (entries[dates[0]] > 0) ? (1.0 / entries[dates[0]]) : 1.0;
                        }
                    }
                    return 1.0;
                } catch (e) {
                    console.warn("FX Error for " + c, e);
                    return 1.0;
                }
            };

            // Cross rate: AmountTarget = AmountSource * (EUR_to_Target / EUR_to_Source)
            // Example: HKD to USD = AmountHKD * (EUR_to_USD / EUR_to_HKD)
            return _calcRate(target) / _calcRate(sourceCurr);
        }

        function renderPeriodButtons() {
            // Default periods if not injected
            const periods = (typeof PERIODS_LIST_JSON !== 'undefined') ? PERIODS_LIST_JSON : [
                { id: '24h', label: '24H' },
                { id: '1w', label: '1W' },
                { id: '1m', label: '1M' },
                { id: '1y', label: '1Y' }
            ];

            const container = el('period-selector');
            if (!container) return;
            container.innerHTML = ''; // Clear to allow re-render

            periods.forEach(p => {
                const btn = document.createElement('a');
                btn.href = `backtest.html?id=${PORTFOLIO_ID}&period=${p.id}&currency=${STATE.currency}`;
                btn.className = `period-btn ${p.id === CURRENT_PERIOD ? 'active' : 'inactive'}`;
                btn.textContent = p.label;

                // If current period page doesn't exist yet, disable link
                btn.onclick = (e) => {
                    if (p.id === CURRENT_PERIOD) {
                        e.preventDefault();
                        return false;
                    }
                };

                container.appendChild(btn);
            });
        }

        // --- Interactivity ---
        window.toggleSubRows = function (id) {
            const rows = document.querySelectorAll(`.sub-row-${id}`);
            const chevron = document.getElementById(`chevron-${id}`);
            let isExpanded = false;

            rows.forEach(r => {
                if (r.style.display === 'none' || r.style.display === '') {
                    r.style.display = 'table-row';
                    isExpanded = true;
                } else {
                    r.style.display = 'none';
                    isExpanded = false;
                }
            });

            if (chevron) {
                chevron.style.transform = isExpanded ? 'rotate(90deg)' : 'rotate(0deg)';
            }
        };

        function init() {
            renderPeriodButtons();
            // Init FX Helpers
            window.FX_KEYS = {};
            if (FX_HISTORY) {
                for (let curr in FX_HISTORY) {
                    window.FX_KEYS[curr] = Object.keys(FX_HISTORY[curr]).sort();
                }
            }

            // Utils
            const debounce = (func, wait) => {
                let timeout;
                return function executedFunction(...args) {
                    const later = () => {
                        clearTimeout(timeout);
                        func(...args);
                    };
                    clearTimeout(timeout);
                    timeout = setTimeout(later, wait);
                };
            };

            const slider = el('timeSlider');
            if (slider && DATA.history.length > 0) {
                // Filter Weekends for Time Machine
                window.VALID_INDICES = [];
                DATA.history.forEach((h, i) => {
                    // Robust Date Parsing
                    const dStr = (typeof h.date === 'string') ? h.date : String(h.date);
                    const dParts = dStr.split('T')[0].split('-');
                    // Month is 0-indexed in JS Date
                    const d = new Date(dParts[0], dParts[1] - 1, dParts[2]);
                    const day = d.getDay();
                    // 0=Sun, 6=Sat
                    if (day !== 0 && day !== 6) {
                        window.VALID_INDICES.push(i);
                    }
                });

                // Fallback if filtering removed everything (unlikely)
                if (window.VALID_INDICES.length === 0) {
                    for (let i = 0; i < DATA.history.length; i++) window.VALID_INDICES.push(i);
                }

                // Initialize Slider Range
                slider.min = 0;
                slider.max = window.VALID_INDICES.length - 1;
                // Default to last valid index
                slider.value = window.VALID_INDICES.length - 1;

                // Debounce Time Machine updates for performance
                const debouncedUpdate = debounce((val) => {
                    const realIdx = window.VALID_INDICES[val];
                    if (realIdx !== undefined) {
                        updateTimeMachine(realIdx);
                    }
                }, 10); // 10ms debounce

                slider.addEventListener('input', (e) => {
                    const val = parseInt(e.target.value);
                    debouncedUpdate(val);
                });
            }

            const ctxEq = el('equityChart');
            if (ctxEq) {
                if (charts.equity) charts.equity.destroy();
                charts.equity = new Chart(ctxEq, {
                    type: 'line',
                    data: { datasets: [] },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        interaction: { mode: 'index', intersect: false },
                        onClick: (e, elements) => {
                            if (elements && elements.length > 0) {
                                const index = elements[0].index;
                                STATE.idx = index;
                                const snap = DATA.history[STATE.idx];
                                const fx = getFX(snap.date, STATE.currency);

                                updatePositions(snap, fx);
                                updateAllocChart(snap, fx);
                                updateTradeIdeas(snap);
                                if (typeof updateLogs === 'function') updateLogs(snap.date, fx);
                            }
                        },
                        scales: {
                            x: {
                                display: true,
                                grid: { display: false },
                                ticks: {
                                    maxTicksLimit: 8,
                                    callback: function (val, index) {
                                        // If Date (T00:00:00) -> Show Day/Month. If Intraday (Txx:xx:00) -> Show Time.
                                        const label = this.getLabelForValue(val); // might be just index or string
                                        // We need the data label
                                        const dataLabel = charts.equity.data.labels[index];                                    // Robust check for Intraday time (T or space separator)
                                        if (dataLabel && (dataLabel.includes('T') || dataLabel.includes(' ')) && !dataLabel.includes('00:00:00')) {
                                            const parts = dataLabel.split(/[T ]/);
                                            if (parts.length > 1) return parts[1].substring(0, 5); // HH:MM
                                        }
                                        // Daily fallback
                                        const d = new Date(dataLabel);
                                        return d.toLocaleDateString(undefined, { month: 'short', day: 'numeric' });
                                    }
                                }
                            },
                            y: { position: 'right', grid: { color: '#f1f5f9' } }
                        },
                        plugins: {
                            legend: {
                                display: true,
                                position: 'top',
                                align: 'end',
                                labels: {
                                    usePointStyle: true,
                                    boxWidth: 8,
                                    font: { size: 10, family: 'Inter' }
                                }
                            },
                            tooltip: {
                                mode: 'index',
                                intersect: false,
                                callbacks: {
                                    label: function (context) {
                                        let label = context.dataset.label || '';
                                        if (label) {
                                            label += ': ';
                                        }
                                        if (context.parsed.y !== null) {
                                            label += fmtPct(context.parsed.y / 100);
                                        }
                                        return label; // Simplified label
                                    }
                                }
                            },
                            zoom: {
                                zoom: {
                                    wheel: { enabled: true },
                                    pinch: { enabled: true },
                                    mode: 'x',
                                },
                                pan: {
                                    enabled: true,
                                    mode: 'x',
                                }
                            }
                        }
                    }
                });
            }

            const ctxAlloc = el('allocChart');
            if (ctxAlloc) {
                if (charts.alloc) charts.alloc.destroy();
                charts.alloc = new Chart(ctxAlloc, {
                    type: 'doughnut',
                    data: { datasets: [{ data: [] }] },
                    options: { cutout: '70%', plugins: { legend: { position: 'right', labels: { boxWidth: 10, font: { size: 10 } } } } }
                });
            }

            // Optimize FX Keys
            if (FX_HISTORY) {
                window.FX_KEYS = {};
                for (let c in FX_HISTORY) {
                    window.FX_KEYS[c] = Object.keys(FX_HISTORY[c]).sort();
                }
            }

            // Init Params
            const params = new URLSearchParams(window.location.search);

            if (DATA.history.length > 0) {
                if (params.get('date')) {
                    const targetStr = params.get('date').split('T')[0].split(' ')[0];
                    let bestIdx = 0;
                    for (let i = 0; i < DATA.history.length; i++) {
                        const hDate = DATA.history[i].date.split('T')[0].split(' ')[0];
                        if (hDate === targetStr) {
                            bestIdx = i;
                            break;
                        }
                        if (hDate > targetStr) {
                            bestIdx = Math.max(0, i - 1);
                            break;
                        }
                        bestIdx = i;
                    }
                    STATE.idx = Math.min(bestIdx, DATA.history.length - 1); // Cap index
                    console.log(`ðŸ•’ Time Machine Jump to: ${targetStr} (Index: ${STATE.idx})`);
                } else {
                    STATE.idx = DATA.history.length - 1;
                }

                // Snap to valid index (Weekdays Only)
                if (window.VALID_INDICES && window.VALID_INDICES.length > 0) {
                    if (!window.VALID_INDICES.includes(STATE.idx)) {
                        // Find closest valid index <= STATE.idx
                        let newIdx = window.VALID_INDICES[0];
                        for (let vi of window.VALID_INDICES) {
                            if (vi <= STATE.idx) newIdx = vi;
                            else break;
                        }
                        STATE.idx = newIdx;
                        console.log(`ðŸ•’ Snapped to Valid Trading Day: Index ${STATE.idx}`);
                    }
                }
                updateTimeMachine(STATE.idx);
            }

            setJournalMode('flat');

            // Set Default Currency from Config or URL
            const defaultCur = params.get('currency') || DATA.currency || 'EUR';
            const curSel = el('currency-selector');
            if (curSel) curSel.value = defaultCur;
            setGlobalCurrency(defaultCur);

            updateStressTest(10);
        }

        function switchTab(id) {
            document.querySelectorAll('.tab-content').forEach(el => el.classList.add('hidden'));
            // Use .nav-tab matching the HTML class
            document.querySelectorAll('.nav-tab').forEach(el => {
                el.classList.remove('active');
            });
            // Fix: Map 'id' (e.g. 'dashboard') to HTML ID 'tab-dashboard'
            const target = el('tab-' + id);
            if (target) target.classList.remove('hidden');

            const btns = document.querySelectorAll('.nav-tab');
            btns.forEach(btn => {
                if (btn.getAttribute('onclick').includes(id)) {
                    btn.classList.add('active');
                }
            });

            // Update content when switching to specific tabs
            if (DATA.history && DATA.history[STATE.idx]) {
                const snap = DATA.history[STATE.idx];
                const fx = getFX(snap.date, STATE.currency);

                if (id === 'ideas') {
                    updateTradeIdeas(snap);
                } else if (id === 'logs') {
                    updateLogs(snap.date, fx);
                } else if (id === 'risk') {
                    updateRisk(snap);
                } else if (id === 'drift') {
                    updateDriftAnalysis();
                }
            }

            // Update charts if needed (resize)
            if (typeof charts.alloc !== 'undefined' && charts.alloc) charts.alloc.resize();
            if (typeof charts.equity !== 'undefined' && charts.equity) charts.equity.resize();
        }

        function setGlobalCurrency(c) {
            console.log("Switching Currency to:", c);
            STATE.currency = c;

            // Update URL with new currency
            const params = new URLSearchParams(window.location.search);
            params.set('currency', c);
            window.history.replaceState({}, '', '?' + params.toString());

            updateEquityChart(); // Recalculate chart with new currency
            updateTimeMachine(STATE.idx); // Force update all stats
        }

        function setCurrencyMode(mode) {
            STATE.posCurrencyMode = mode;
            // Update Button Styles
            const btnGlobal = el('btn-global');
            const btnNative = el('btn-native');
            // Simple toggle styling (active vs inactive)
            const activeClass = "px-3 py-1 text-xs font-bold rounded-md bg-white text-blue-600 shadow-sm border border-transparent transition-all transform scale-105";
            const inactiveClass = "px-3 py-1 text-xs font-bold rounded-md text-slate-500 hover:bg-white hover:text-slate-700 border border-transparent transition-all";

            if (btnGlobal) btnGlobal.className = mode === 'GLOBAL' ? activeClass : inactiveClass;
            if (btnNative) btnNative.className = mode === 'NATIVE' ? activeClass : inactiveClass;

            // Refresh Positions using current Time Machine state
            if (DATA.history && DATA.history[STATE.idx]) {
                updatePositions(DATA.history[STATE.idx], getFX(DATA.history[STATE.idx].date, STATE.currency));
            }
        }

        function drawSparkline(id, data, color) {
            const cvs = document.getElementById(id);
            if (!cvs) return;
            const ctx = cvs.getContext('2d');
            const w = cvs.width;
            const h = cvs.height;
            ctx.clearRect(0, 0, w, h);
            if (!data || data.length < 2) return;
            let min = Infinity, max = -Infinity;
            for (let v of data) { if (v < min) min = v; if (v > max) max = v; }
            const range = max - min || 1;
            const step = w / (data.length - 1);
            ctx.beginPath();
            ctx.strokeStyle = color;
            ctx.lineWidth = 2;
            ctx.lineJoin = 'round';
            for (let i = 0; i < data.length; i++) {
                const y = h - 2 - ((data[i] - min) / range * (h - 4));
                if (i === 0) ctx.moveTo(0, y); else ctx.lineTo(i * step, y);
            }
            ctx.stroke();
            const grad = ctx.createLinearGradient(0, 0, 0, h);
            grad.addColorStop(0, color + '40');
            grad.addColorStop(1, color + '00');
            ctx.lineTo(w, h); ctx.lineTo(0, h);
            ctx.fillStyle = grad; ctx.fill();
        }

        function updateTimeMachine(idx) {
            STATE.idx = idx;

            // Sync slider if valid mapping exists
            const slider = el('timeSlider');
            if (slider && window.VALID_INDICES) {
                const logicalIdx = window.VALID_INDICES.indexOf(idx);
                if (logicalIdx !== -1) {
                    slider.value = logicalIdx;
                }
            }

            const snap = DATA.history[idx];
            if (!snap) return;

            const tmDateEl = el('tm-date');
            if (DATA.history && idx === DATA.history.length - 1) {
                tmDateEl.className = 'font-mono text-sm font-black text-emerald-600';
                tmDateEl.innerHTML = `<span class="bg-emerald-100 text-emerald-700 px-1.5 py-0.5 rounded text-[10px] mr-2">LIVE</span>${fmtDate(snap.date)}`;
            } else {
                tmDateEl.className = 'font-mono text-sm font-bold text-slate-700';
                tmDateEl.innerText = fmtDate(snap.date);
            }

            let fx = 1.0;
            try { fx = getFX(snap.date, STATE.currency); } catch (e) { }

            const datePart = snap.date.split('T')[0].split(' ')[0];
            // Fix: Do NOT auto-update Calendar Month/Year when time changes.
            // User wants manual control via buttons only.
            // const [y, m] = datePart.split('-').map(Number);
            // STATE.calYear = y; STATE.calMonth = m;
            if (STATE.journalMode === 'calendar') { renderCalendar(); showDayDetail(datePart); }

            const stats = calculateWindowStats(idx);
            el('kpi-return').innerText = fmtPct(stats.ret);
            el('kpi-return').className = stats.ret >= 0 ? "text-2xl font-black text-emerald-600" : "text-2xl font-black text-rose-600";
            el('kpi-dd').innerText = fmtPct(stats.dd);
            el('kpi-vol').innerText = fmtPct(stats.vol);
            // el('stat-r2').innerText = (typeof stats.r2 === 'number' && !isNaN(stats.r2)) ? stats.r2.toFixed(2) : "--";
            // el('stat-trades').innerText = stats.trades || "0";

            // Use Win Rate from calculateWindowStats for consistency with Snapshot Stats
            el('kpi-winrate').innerText = fmtPct(stats.winrate || 0);

            // Sparklines Decimation
            const slice = DATA.history.slice(0, idx + 1);
            let sub = slice;
            if (slice.length > 300) {
                const s = Math.ceil(slice.length / 150);
                sub = slice.filter((_, i) => i % s === 0);
                sub.push(slice[slice.length - 1]);
            }

            // Update Dynamic Stats Grid
            if (window.updateStatsGridValues) {
                updateStatsGridValues(snap, fx, sub, stats);
            }

            updateEquityChart();
            updateAllocChart(snap, fx);
            updatePositions(snap, fx);
            updateOrders(snap, fx);
            updateRisk(snap);
            updateLogs(snap.date, fx);
            updateTimeline(snap.date);
            updateTopHoldings(snap, fx);
            updateTradeIdeas(snap);
            updateCorrelationMatrix(snap);
            updateBestWorstTrades(snap.date, fx);

            if (STATE.journalMode === 'accounting') {
                renderAccountingView();
            }
        }

        function calculateWindowStats(currentIdx) {
            const history = DATA.history;
            if (!history || history.length === 0) return { ret: 0, dd: 0, vol: 0, trades: 0, r2: 0, sharpe: 0, winrate: 0 };

            // Calculate stats from start to currentIdx
            const periodData = history.slice(0, currentIdx + 1);
            if (periodData.length < 2) return { ret: 0, dd: 0, vol: 0, r2: 0, trades: 0, sharpe: 0, winrate: 0 };

            const cur = STATE.currency;

            // Apply FX to start/end equity
            const startFx = getFX(periodData[0].date, cur);
            const endFx = getFX(periodData[periodData.length - 1].date, cur);

            // Return logic
            const startEq = periodData[0].equity * startFx;
            const endEq = periodData[periodData.length - 1].equity * endFx;
            const ret = startEq > 0 ? (endEq - startEq) / startEq : 0;

            // Re-calculate DD and Vol based on Converted Series
            const convertedSeries = periodData.map(h => h.equity * getFX(h.date, cur));

            // Max Drawdown: Track the most negative drawdown (dd is always <= 0)
            let maxEq = -Infinity;
            let maxDD = 0; // Will store the most negative value (worst drawdown)

            convertedSeries.forEach(val => {
                if (val > maxEq) maxEq = val;
                if (maxEq > 0) {
                    const dd = (val - maxEq) / maxEq; // dd is negative or 0
                    if (dd < maxDD) maxDD = dd; // Keep track of worst (most negative) drawdown
                }
            });

            // Calculate returns for volatility and Sharpe
            const returns = [];
            for (let i = 1; i < convertedSeries.length; i++) {
                if (convertedSeries[i - 1] > 0) {
                    const r = (convertedSeries[i] - convertedSeries[i - 1]) / convertedSeries[i - 1];
                    returns.push(r);
                }
            }

            // Annualized Volatility: Use sqrt(252) for daily data
            const multiplier = 252;
            const vol = returns.length > 0 ? (Math.sqrt(returns.reduce((a, b) => a + b * b, 0) / returns.length) * Math.sqrt(multiplier)) : 0;

            // RÂ² (Linearity on Converted Series)
            const n = convertedSeries.length;
            const x = Array.from({ length: n }, (_, i) => i);
            const y = convertedSeries;
            const sumX = x.reduce((a, b) => a + b, 0);
            const sumY = y.reduce((a, b) => a + b, 0);
            const sumXY = x.reduce((a, b, i) => a + b * y[i], 0);
            const sumX2 = x.reduce((a, b) => a + b * b, 0);
            const sumY2 = y.reduce((a, b) => a + b * b, 0);

            const num = n * sumXY - sumX * sumY;
            const den = Math.sqrt((n * sumX2 - sumX * sumX) * (n * sumY2 - sumY * sumY));
            const r = den !== 0 ? num / den : 0;
            const r2 = r * r;

            // Trades Count & Winrate
            // Use date part only (YYYY-MM-DD) for comparison to handle format mismatches
            const pStartDate = getDatePart(periodData[0].date);
            const pEndDate = getDatePart(periodData[periodData.length - 1].date);

            const windowTrades = TRADES.filter(t => {
                const tradeDate = getDatePart(t.Date);
                // Exclude Entry Orders (BUY/ADD) for accurate Trade Stats
                // We only want closed trades (SELL, STOP, CLOSE, TIMEOUT, etc.)
                const isEntry = t.Action.includes('BUY') || t.Action.includes('ADD') || t.Action === 'OPEN' || t.Action === 'TRAIL'; return !isEntry && tradeDate >= pStartDate && tradeDate <= pEndDate;
            });
            const tradeCount = windowTrades.length;
            const wins = windowTrades.filter(t => (t.PnL || 0) > 0).length;
            const wr = tradeCount > 0 ? wins / tradeCount : 0;

            // Sharpe Ratio: Require minimum 10 data points for stability
            let sharpe2 = 0;
            if (returns.length >= 10) {
                const meanRet = returns.reduce((a, b) => a + b, 0) / returns.length;
                const variance = returns.reduce((a, b) => a + (b - meanRet) ** 2, 0) / returns.length;
                const stdRet = Math.sqrt(variance);
                // Annualized Sharpe: (annualized mean return) / (annualized std)
                sharpe2 = stdRet > 0 ? (meanRet * 252) / (stdRet * Math.sqrt(252)) : 0;
            }

            return { ret, retVal: endEq - startEq, max_dd: maxDD, dd: maxDD, vol, r2, trades_count: tradeCount, trades: tradeCount, sharpe: sharpe2, winrate: wr || 0 };
        }

        function fmtDate(d) {
            if (!d) return '';
            const s = String(d).replace(' ', 'T');
            if (s.includes('T')) {
                const parts = s.split('T');
                const datePart = parts[0];
                const timePart = parts[1] ? parts[1].substring(0, 5) : '';

                const isIntraday = ['24h', '48h', '1w', '2w'].includes(CURRENT_PERIOD);
                if ((timePart !== '00:00' && timePart !== '') || isIntraday) {
                    return datePart + ' ' + timePart;
                }
                return datePart;
            }
            return d;
        }

        // Helper to extract date portion (YYYY-MM-DD) from any date format
        function getDatePart(d) {
            if (!d) return '';
            const s = String(d).replace(' ', 'T');
            return s.split('T')[0];
        }

        // Helper to compare dates (returns -1, 0, or 1) - Supports ISO T separator
        function compareDates(a, b) {
            if (!a || !b) return 0;
            const norm = s => String(s).replace(' ', 'T').slice(0, 19); // YYYY-MM-DDTHH:MM:SS
            const sA = norm(a);
            const sB = norm(b);
            return sA < sB ? -1 : (sA > sB ? 1 : 0);
        }

        function fmtDuration(seconds, period) {
            if (seconds === undefined || seconds === null || seconds < 0) return '0d';
            const mins = Math.floor(seconds / 60);
            const hours = Math.floor(mins / 60);
            const days = Math.floor(hours / 24);

            const isIntraday = ['24h', '48h', '1w', '2w'].includes(period);

            if (!isIntraday) {
                if (days === 0) return '0d';
                return days + 'd';
            }

            // Intraday logic
            if (days >= 1) return days + 'd ' + (hours % 24) + 'h';
            if (hours > 0) return hours + 'h ' + (mins % 60) + 'm';
            if (mins === 0 && seconds > 0) return '<1m';
            return mins + 'm';
        }



        // Check if trade date is within range (handles both daily and intraday)
        function isDateInRange(tradeDate, startDate, endDate) {
            // Strictly use compareDates for inclusive range check
            return compareDates(tradeDate, startDate) >= 0 && compareDates(tradeDate, endDate) <= 0;
        }

        function updateEquityChart() {
            const history = DATA.history;
            const currentIdx = STATE.idx;

            // Safety check
            if (!history || history.length === 0 || currentIdx < 0 || !history[0]) return;

            // Show all history from start to current index
            const subset = history.slice(0, currentIdx + 1);
            const labels = subset.map(x => fmtDate(x.date));

            charts.equity.data.labels = labels;

            const fxStart = getFX(subset[0].date, STATE.currency);
            const baseEq = subset[0].equity * fxStart;

            const data = subset.map(x => {
                const fx = getFX(x.date, STATE.currency);
                const val = x.equity * fx;
                return (baseEq > 0.00001) ? (val - baseEq) / baseEq * 100 : 0;
            });

            charts.equity.data.datasets = [{
                label: 'Portfolio',
                data: data,
                borderColor: '#2563eb',
                fill: true,
                backgroundColor: 'rgba(37, 99, 235, 0.1)',
                borderWidth: 2,
                pointRadius: 0,
                tension: 0.1
            }];


            if (BENCH) {
                // Clear old bench datasets first? 
                // chart.js keeps reference. We should rebuild datasets array or keep index 0
                // For simplicity, let's keep index 0 (Portfolio) and append Benches

                const datasets = [charts.equity.data.datasets[0]];

                // Colors for known benchmarks
                const colors = { 'S&P 500': '#64748b', 'Gold': '#f59e0b', 'Bitcoin': '#f97316', 'Euro Stoxx 50': '#3b82f6' };

                for (let bName in BENCH) {
                    const bDataObj = BENCH[bName];
                    // Align with subset dates
                    // Normalized to 0% at start of the visible window
                    let basePrice = 0;
                    const startD = getDatePart(subset[0].date); // Fix: strip time

                    if (bDataObj[startD]) {
                        basePrice = bDataObj[startD];
                    } else {
                        // Fallback: Find first valid date >= startD
                        const sortedDates = Object.keys(bDataObj).sort();
                        const firstValid = sortedDates.find(d => d >= startD);
                        if (firstValid) basePrice = bDataObj[firstValid];
                        else if (sortedDates.length > 0) basePrice = bDataObj[sortedDates[0]]; // fallback to first ever
                    }

                    const bSeries = subset.map(h => {
                        const dateKey = getDatePart(h.date); // Fix: strip time
                        const p = bDataObj[dateKey];
                        // If data missing for this specific day, ideally forward fill?
                        // For now, if missing, null (broken line) or we could hold prev value.
                        // Holding prev value is better for charts.
                        if (p && basePrice > 0) return (p - basePrice) / basePrice * 100;
                        return null;
                    });

                    // Add to chart
                    datasets.push({
                        label: bName,
                        data: bSeries,
                        borderColor: colors[bName] || '#94a3b8',
                        borderWidth: 1.5,
                        pointRadius: 0,
                        fill: false,
                        hidden: true // Default hidden? Or User toggle. 
                        // With interactive legend, visible is better.
                    });
                }
                charts.equity.data.datasets = datasets;
            }

            charts.equity.update('none');
        }

        function getSymbolCurrency(sym, country) {
            if (sym.includes("EUR") || sym.includes(".DE") || sym.includes(".PA") || sym.includes(".MI") || sym.includes(".AS")) return "EUR";
            if (sym.includes("USD") || sym === "SPY" || sym === "GLD" || country === "US") return "USD";
            if (sym.includes("HKD") || sym.includes(".HK") || country === "HK") return "HKD";
            if (sym.includes("GBP") || sym.includes(".L") || country === "UK") return "GBP";
            if (sym.includes("CHF") || sym.includes(".SW") || country === "CH") return "CHF";
            if (sym.includes("JPY") || sym.includes(".T") || country === "JP") return "JPY";
            return "USD"; // Default
        }

        function updatePositions(snap, globalFx) {
            const tbody = el('pos-body');
            if (!tbody) return;
            tbody.innerHTML = '';

            const pendingOrders = snap.pending_orders || [];
            const mode = STATE.posCurrencyMode;
            const totalEq = snap.equity * globalFx;

            let sortedPos = [...(snap.positions || [])];

            sortedPos.forEach(p => {
                let rowFx = 1.0;
                let symCurr = STATE.currency; // Default to global

                if (mode === 'NATIVE') {
                    let native = getSymbolCurrency(p.symbol, p.country);
                    let rate = getFX(snap.date, native);
                    if (rate && rate > 0) rowFx = 1.0 / rate;
                    symCurr = native;
                } else {
                    rowFx = globalFx;
                }

                p._viewPrice = (p.price || 0) * rowFx;
                p._viewValue = (p.value || 0) * rowFx;
                p._viewPnL = (p.unrealized_pnl || 0) * rowFx;
                p._viewCost = (p.avg_cost || 0) * rowFx;
                p._viewSL = (p.stop_loss || 0) * rowFx;
                p._viewCurr = symCurr;

                // Weight is always based on Global Value
                const valGlobal = (p.value || 0) * globalFx;
                p._weight = (totalEq > 0) ? (valGlobal / totalEq * 100) : 0;

                // Impact % = PnL (Global) / Total Equity (Global)
                const pnlGlobal = (p.unrealized_pnl || 0) * globalFx;
                p._impact = (totalEq > 0) ? (pnlGlobal / totalEq * 100) : 0;
            });

            // Sort
            sortedPos.sort((a, b) => {
                let va, vb;
                const col = STATE.sort.pos.col;
                // Map columns
                if (col === 'symbol') { va = a.symbol; vb = b.symbol; }
                else if (col === 'type') { va = a.assetType; vb = b.assetType; }
                else if (col === 'shares') { va = a.shares; vb = b.shares; }
                else if (col === 'price') { va = a._viewPrice; vb = b._viewPrice; }
                else if (col === 'value') { va = a._viewValue; vb = b._viewValue; }
                else if (col === 'pnl') { va = a._viewPnL; vb = b._viewPnL; }
                else if (col === 'duration') { va = a.duration; vb = b.duration; }
                else if (col === 'weight') { va = a._weight; vb = b._weight; }
                else if (col === 'impact') { va = a._impact; vb = b._impact; } // Impact Sort
                else if (col === 'avg_cost') { va = a._viewCost; vb = b._viewCost; }
                else if (col === 'sl') { va = a._viewSL; vb = b._viewSL; }
                else { va = a.value; vb = b.value; }

                if (typeof va === 'string') return va.localeCompare(vb) * STATE.sort.pos.dir;
                return (va - vb) * STATE.sort.pos.dir;
            });


            // Update Summary Indicators in Header (Count + Popover)
            const count = snap.positions ? snap.positions.length : 0;
            if (el('header-count')) el('header-count').innerText = count;

            // Calculate Dashboard-Aligned Metrics for Popover Details
            // 1. Unrealized (From Positions)
            let sumUnrealizedGlobal = 0;
            let sumPositionsValueGlobal = 0;
            let sumMaxLossGlobal = 0;
            snap.positions.forEach(p => {
                sumUnrealizedGlobal += (p.unrealized_pnl || 0);
                sumPositionsValueGlobal += (p.value || 0);
                if ((p.stop_loss || 0) > 0) {
                    // Risk = (StopLoss - Price) * Shares
                    const risk = (p.stop_loss - p.price) * p.shares;
                    sumMaxLossGlobal += risk;
                }
            });

            // 2. Realized (From GLOBAL TRADES using Dashboard Logic)
            // Logic must match updateSnapshot() for consistency.
            // Uses t.PnL and t.Date
            const relevantTrades = TRADES.filter(t => compareDates(t.Date, snap.date) <= 0 && t.PnL !== 0);
            const sumRealizedGlobal = relevantTrades.reduce((sum, t) => sum + (t.PnL || 0), 0);

            // 3. Total Equity
            const totalEqGlobal = snap.equity || 0;

            // 4. Convert to Selected Display Currency
            const valUnrealized = sumUnrealizedGlobal * globalFx;
            const valPositions = sumPositionsValueGlobal * globalFx;
            const valRealized = sumRealizedGlobal * globalFx;
            const valMaxLoss = sumMaxLossGlobal * globalFx;
            const valEquity = totalEqGlobal * globalFx;

            // 5. Percentages (Base on Current Equity)
            const eqBase = valEquity > 0 ? valEquity : 1;
            const pctUnrealized = (valUnrealized / eqBase) * 100;
            const pctPositions = (valPositions / eqBase) * 100;
            const pctRealized = (valRealized / eqBase) * 100;
            const pctMaxLoss = (valMaxLoss / eqBase) * 100;

            // 6. Update Popover DOM Elements
            const setPop = (id, val, pct, isLoss = false) => {
                const elVal = el(id + '-val');
                const elPct = el(id + '-pct');
                if (elVal) elVal.innerText = fmtMoney(val, STATE.currency);
                if (elPct) {
                    elPct.innerText = pct.toFixed(1) + "%"; // Removed +/- sign for Positions Value (usually positive)
                    // Color logic for Pct
                    if (val >= 0 && !isLoss) {
                        elPct.className = "text-[10px] font-medium text-slate-600"; // Neutral color for Exposure
                    } else {
                        elPct.className = "text-[10px] font-medium text-rose-600";
                    }
                }
            };

            setPop('pop-unrealized', valPositions, pctPositions);
            setPop('pop-realized', valRealized, pctRealized);
            setPop('pop-maxloss', valMaxLoss, pctMaxLoss, true);

            if (el('pop-equity-val')) el('pop-equity-val').innerText = fmtMoney(valEquity, STATE.currency);
            if (el('pop-equity-pct')) {
                const pctTotal = ((valRealized + valUnrealized) / (valEquity > 0 ? valEquity : 1)) * 100;
                el('pop-equity-pct').innerText = (pctTotal >= 0 ? "+" : "") + pctTotal.toFixed(1) + "%";
                el('pop-equity-pct').className = pctTotal >= 0 ? "text-[10px] font-bold text-emerald-600" : "text-[10px] font-bold text-rose-600";
            }

            // Removed Targets logic


            sortedPos.forEach(p => {
                const tr = document.createElement('tr');
                tr.className = "hover:bg-slate-50 transition-colors border-b border-slate-50 last:border-0 cursor-pointer";
                tr.setAttribute('onclick', `toggleSubRows('${p.symbol.replace(/\W/g, '_')}')`);

                // Styling
                const pnlClass = p._viewPnL >= 0 ? "text-emerald-600 font-bold" : "text-rose-600 font-bold";
                const impactClass = p._impact >= 0 ? "text-emerald-600" : "text-rose-600";
                const curSym = p._viewCurr;
                const weightPct = p._weight;

                // Row-specific orders check (Pending OR Metadata SL)
                const rowHasDetails = pendingOrders.some(o => o.symbol === p.symbol) || (p.stop_loss && p.stop_loss > 0) || (p.entry_history && p.entry_history.length > 0);

                tr.innerHTML = `
                    <td class="px-4 py-3 font-medium text-slate-800 group" title="Click to view Execution Plan">
                        <div class="flex items-center">
                            ${rowHasDetails ? '<div class="w-4 flex justify-center mr-2"><i id="chevron-' + p.symbol.replace(/\W/g, '_') + '" class="fa-solid fa-chevron-right text-sm text-blue-400 group-hover:text-blue-600 transition-transform"></i></div>' : '<div class="w-4 mr-2"></div>'}
                            <span class="mr-2 text-base">${getCountryFlag(p.symbol)}</span>
                            <a href="https://finance.yahoo.com/quote/${p.symbol}" target="_blank" onclick="event.stopPropagation()" class="mr-2 font-bold group-hover:text-blue-600 hover:underline transition-colors">${p.symbol}</a>
                            ${p.assetType === 'Crypto' ? '<i class="fa-brands fa-bitcoin text-orange-500 text-xs text-opacity-70"></i>' : ''}
                        </div>
                    </td>
                    <!-- Removed redundant Type column to fix alignment with header -->
                    <td class="px-4 py-3 text-right font-mono text-slate-600">${fmtNum(p.shares)}</td>
                    <td class="px-4 py-3 text-right font-mono text-slate-500 text-xs">${fmtMoney(p._viewCost, curSym)}</td>
                    <td class="px-4 py-3 text-right font-mono text-slate-800 font-bold">${fmtMoney(p._viewPrice, curSym)}</td>

                    <td class="px-4 py-3 text-right font-mono text-slate-800 font-bold">${fmtMoney(p._viewValue, curSym)}</td>
                    <td class="px-4 py-3 text-right font-mono ${pnlClass}">${fmtMoney(p._viewPnL, curSym)}</td>
                    <td class="px-4 py-3 text-right font-mono text-slate-500 text-xs">${fmtDuration(p.duration, CURRENT_PERIOD)}</td>
                    <td class="px-4 py-3 text-right font-mono text-slate-600 text-xs">${weightPct.toFixed(1)}%</td>
                    <td class="px-4 py-3 text-right font-mono text-xs ${impactClass}">${p._impact > 0 ? '+' : ''}${p._impact.toFixed(2)}%</td>
                `;
                tbody.appendChild(tr);

                // Sub-rows for Active Orders (Targets) OR Existing Stop Loss Metadata
                if (rowHasDetails) {
                    let subRowsContent = '';

                    // 1. Pending Orders
                    const subOrders = (snap.pending_orders || []).filter(o => o.symbol === p.symbol && (String(o.type).includes('STOP') || String(o.type).includes('LIMIT') || String(o.action).includes('PROFIT')));

                    subOrders.forEach(o => {
                        const ot = String(o.type).toUpperCase();
                        let typeLabel = 'TARGET';
                        let rowBg = 'bg-slate-50/50';
                        let typeColor = 'text-slate-500';

                        if (ot.includes('STOP')) { typeLabel = 'STOP LOSS'; rowBg = 'bg-rose-50/30'; typeColor = 'text-rose-600'; }
                        else if (ot.includes('LIMIT') || String(o.action).toUpperCase().includes('PROFIT')) { typeLabel = 'TAKE PROFIT'; rowBg = 'bg-emerald-50/30'; typeColor = 'text-emerald-600'; }

                        // Price Logic
                        const isNativeMode = (STATE.posCurrencyMode === 'NATIVE' || STATE.posCurrencyMode === 'RAW');
                        const native = getSymbolCurrency(p.symbol, p.country);
                        // const fxReport = getFX(snap.date, STATE.currency); // Unused
                        // const fxNative = getFX(snap.date, native); // Unused
                        const curDisplay = isNativeMode ? native : STATE.currency;

                        let priceDisplay = o.price;
                        if (!isNativeMode) {
                            priceDisplay = o.price * globalFx; // Approx conversion using global rate
                        }

                        subRowsContent += `
                            <tr class="sub-row-${p.symbol.replace(/\W/g, '_')} ${rowBg} text-xs" style="display:none;">
                                <td class="px-4 py-2 border-l-4 border-transparent"></td> <!--Indent -->
                                <td colspan="2" class="px-4 py-2 font-mono text-slate-500 text-right">
                                    <span class="mr-2">@ ${fmtMoney(priceDisplay, curDisplay)}</span>
                                </td>
                                <td class="px-4 py-2 text-center">
                                    <span class="text-[9px] font-bold uppercase tracking-wider ${typeColor} border border-${typeColor.replace('text-', '')}-200 px-1 rounded bg-white">${typeLabel}</span>
                                </td>
                                <td colspan="5"></td>
                            </tr>
                        `;
                    });

                    // 2. Generate TRADE PLAN section (Entry, Risk, Take Profits, DCA)
                    // NOTE: All values in p.* are ALREADY converted to report currency (EUR) by the pipeline
                    // For NATIVE mode, we use the native_* fields stored in the position
                    const isNativeMode = (STATE.posCurrencyMode === 'NATIVE');
                    const native = getSymbolCurrency(p.symbol, p.country);
                    const curDisplay = isNativeMode ? native : STATE.currency;

                    // Entry Info - use appropriate source based on mode
                    const avgCost = isNativeMode ? (p.native_avg_cost || p.avg_cost || 0) : ((p.avg_cost || 0) * globalFx);
                    const currentPrice = isNativeMode ? (p.native_price || p.price || 0) : ((p.price || 0) * globalFx);
                    const entries = p.entries || 1;
                    const maxEntries = p.max_entries || 3;
                    const dcaRemaining = maxEntries - entries;

                    // For native mode, we need to convert EUR values back to native
                    // The pipeline stores: native_price (HKD), price (EUR)
                    const nativeConvFactor = (p.native_price && p.price && p.price > 0) ? (p.native_price / p.price) : 1;

                    // Stop Loss
                    const sl = isNativeMode ? ((p.stop_loss || 0) * nativeConvFactor) : ((p.stop_loss || 0) * globalFx);
                    const slPct = avgCost > 0 ? ((sl - avgCost) / avgCost * 100) : 0;

                    // Take Profit levels (already in EUR from pipeline, need conversion for display)
                    let tpLevels = [];
                    if (p.tp_levels && p.tp_levels.length > 0) {
                        tpLevels = p.tp_levels.map(tp => {
                            const tpPrice = isNativeMode ? (tp.price * nativeConvFactor) : (tp.price * globalFx);
                            return {
                                level: tp.level,
                                price: tpPrice,
                                pct: tp.pct,
                                gain: avgCost > 0 ? ((tpPrice - avgCost) / avgCost * 100) : 0
                            };
                        });
                    }

                    // Next DCA price
                    const nextDca = p.next_dca_price ?
                        (isNativeMode ? (p.next_dca_price * nativeConvFactor) : (p.next_dca_price * globalFx))
                        : null;
                    const nextDcaPct = avgCost > 0 && nextDca ? ((nextDca - currentPrice) / currentPrice * 100) : 0;

                    // Build Trade Plan Sub-rows - TIMELINE FORMAT
                    // Header row - use blue theme to match interface
                    subRowsContent += `
                        <tr class="sub-row-${p.symbol.replace(/\W/g, '_')} text-xs font-bold" style="display:none;">
                            <td colspan="10" style="background:linear-gradient(135deg, #1e40af 0%, #3b82f6 100%); color:#f8fafc; padding:12px 16px;">
                                <div class="flex items-center justify-between">
                                    <div class="flex items-center gap-6">
                                        <span class="uppercase tracking-wider"><i class="fa-solid fa-list-check mr-2"></i>EXECUTION PLAN</span>
                                        <span style="color:#bfdbfe;" class="font-normal">Avg Cost: <span style="color:#fff;" class="font-bold">${fmtMoney(avgCost, curDisplay)}</span></span>
                                        <span style="color:#bfdbfe;" class="font-normal">Current: <span style="color:#fff;" class="font-bold">${fmtMoney(currentPrice, curDisplay)}</span></span>
                                    </div>
                                    <div class="flex items-center gap-2">
                                        <span style="background:rgba(255,255,255,0.2); color:#fff; padding:2px 8px; border-radius:4px; font-size:10px;">Entry ${entries}/${maxEntries}</span>
                                        ${sl > 0 ? `<span style="background:#dc2626; color:#fff; padding:2px 8px; border-radius:4px; font-size:10px;">SL: ${fmtMoney(sl, curDisplay)}</span>` : ''}
                                    </div>
                                </div>
                            </td>
                        </tr>
                    `;

                    // ========== SECTION 0: TRANSACTION HISTORY (Full Context) ==========
                    const historyTrades = (TRADES || []).filter(t => t.symbol === p.symbol && t.date <= snap.date);
                    if (historyTrades.length > 0) {
                        // Sort descending date
                        historyTrades.sort((a, b) => new Date(b.date) - new Date(a.date));

                        subRowsContent += `
                            <tr class="sub-row-${p.symbol.replace(/\W/g, '_')} bg-slate-50 text-xs" style="display:none;">
                                <td colspan="10" class="px-4 py-1 text-center border-b border-slate-200 bg-slate-100">
                                    <span class="text-slate-500 text-[10px] uppercase tracking-wider font-bold">TRANSACTION HISTORY</span>
                                </td>
                            </tr>
                        `;

                        historyTrades.forEach(t => {
                            let actionColor = 'text-slate-600';
                            let icon = 'fa-circle-dot';
                            let bgClass = 'bg-white';

                            const act = String(t.action).toUpperCase();
                            if (act.includes('BUY')) { actionColor = 'text-emerald-600'; icon = 'fa-arrow-right-to-bracket'; }
                            if (act.includes('SELL')) { actionColor = 'text-rose-600'; icon = 'fa-arrow-right-from-bracket'; bgClass = 'bg-rose-50/20'; }
                            if (act.includes('TRIM') || act.includes('TIMEOUT')) { actionColor = 'text-orange-500'; icon = 'fa-scissors'; bgClass = 'bg-orange-50/20'; }

                            let tPrice = t.price;
                            // Convert if needed
                            if (!isNativeMode) {
                                const fxToNative = getFX(t.date, native);
                                if (fxToNative > 0) tPrice = t.price / fxToNative;
                            }

                            subRowsContent += `
                                <tr class="sub-row-${p.symbol.replace(/\W/g, '_')} ${bgClass} text-xs border-b border-slate-50" style="display:none;">
                                    <td class="px-4 py-2 border-l-4 border-slate-200"></td>
                                    <td class="px-4 py-2 text-slate-400 w-8 text-center"><i class="fa-solid ${icon}"></i></td>
                                    <td class="px-4 py-2" colspan="2">
                                        <div class="flex flex-col">
                                            <span class="font-bold ${actionColor}">${t.action}</span>
                                            <span class="text-slate-400 text-[10px]">${t.reason || '-'}</span>
                                        </div>
                                    </td>
                                    <td class="px-4 py-2 text-right font-mono text-slate-500">${fmtDate(t.date)}</td>
                                    <td class="px-4 py-2 text-right font-mono">${fmtNum(t.shares)}</td>
                                    <td class="px-4 py-2 text-right font-mono">@ ${fmtMoney(tPrice, curDisplay)}</td>
                                    <td colspan="3"></td>
                                </tr>
                            `;
                        });
                    }

                    // ========== SECTION 1: PAST ACTIONS (Entries done) ==========
                    // Filter entry_history to show only ACTIVE entries (those that make up current shares)
                    const fullEntryHistory = p.entry_history || [];
                    const entryHistory = [];

                    if (fullEntryHistory.length > 0 && p.shares > 0) {
                        // Sort by date (most recent first) - assumes LIFO
                        const sorted = [...fullEntryHistory].sort((a, b) => {
                            const dateA = new Date(a.date);
                            const dateB = new Date(b.date);
                            return dateB - dateA; // descending
                        });

                        // Accumulate shares from most recent entries until we reach current total
                        let accumulated = 0;
                        for (const entry of sorted) {
                            if (accumulated >= p.shares) break;
                            entryHistory.unshift(entry); // Add to beginning to restore chronological order
                            accumulated += (entry.qty || 0);
                        }
                    }

                    if (entryHistory.length > 0) {
                        entryHistory.forEach((entry, idx) => {
                            // entry.price is already in EUR (report currency)
                            // entry.native_price is the original native currency price
                            const entryPrice = isNativeMode ? (entry.native_price || entry.price) : (entry.price * globalFx);
                            const entryQty = entry.qty || 0;
                            const entryDate = fmtDate(entry.date);
                            const isDCA = entry.is_dca;
                            const entryLabel = isDCA ? `DCA #${entry.entry_num}` : `Initial Entry`;
                            const pctOfTotal = (p.shares > 0) ? Math.round(entryQty / p.shares * 100) : 0;

                            subRowsContent += `
                                <tr class="sub-row-${p.symbol.replace(/\W/g, '_')} bg-emerald-50/40 text-xs" style="display:none;">
                                    <td class="px-4 py-2 border-l-4 border-emerald-500"></td>
                                    <td class="px-4 py-2 text-emerald-600 font-bold w-8">
                                        <i class="fa-solid fa-circle-check text-emerald-500"></i>
                                    </td>
                                    <td class="px-4 py-2">
                                        <span class="font-bold text-emerald-700">${entryLabel}</span>
                                        <span class="text-slate-400 ml-2 text-[10px]">${entryDate}</span>
                                    </td>
                                    <td class="px-4 py-2 font-mono text-emerald-700 font-bold text-right">${fmtMoney(entryPrice, curDisplay)}</td>
                                    <td class="px-4 py-2 font-mono text-slate-600">${fmtNum(entryQty)} shares</td>
                                    <td colspan="4" class="px-4 py-2 text-slate-400 text-right">
                                        <span class="bg-emerald-100 text-emerald-700 px-2 py-0.5 rounded text-[10px] font-bold">BUY ${fmtNum(entryQty)} @ ${fmtMoney(entryPrice, curDisplay)} (${pctOfTotal}%)</span>
                                    </td>
                                </tr>
                            `;
                        });
                    }

                    // ========== SECTION 2: PENDING ACTIONS ==========
                    // Separator if we have both past and future
                    if (entryHistory.length > 0 && (nextDca || tpLevels.length > 0 || sl > 0)) {
                        subRowsContent += `
                            <tr class="sub-row-${p.symbol.replace(/\W/g, '_')} bg-slate-100 text-xs" style="display:none;">
                                <td colspan="10" class="px-4 py-1 text-center">
                                    <span class="text-slate-400 text-[10px] uppercase tracking-wider font-bold">â–¼ NEXT STEPS â–¼</span>
                                </td>
                            </tr>
                        `;
                    }

                    // NEXT DCA (if available)
                    if (nextDca && dcaRemaining > 0) {
                        subRowsContent += `
                            <tr class="sub-row-${p.symbol.replace(/\W/g, '_')} bg-blue-50/40 text-xs" style="display:none;">
                                <td class="px-4 py-2 border-l-4 border-blue-500"></td>
                                <td class="px-4 py-2 text-blue-500 w-8">
                                    <i class="fa-solid fa-cart-plus"></i>
                                </td>
                                <td class="px-4 py-2">
                                    <span class="font-bold text-blue-700">DCA #${entries + 1}</span>
                                    <span class="text-slate-400 ml-2 text-[10px]">PENDING</span>
                                </td>
                                <td class="px-4 py-2 font-mono text-blue-700 font-bold text-right">${fmtMoney(nextDca, curDisplay)}</td>
                                <td class="px-4 py-2 font-mono text-slate-600">Est. +${fmtNum(Math.round(p.shares / (entries || 1)))} shares</td>
                                <td colspan="4" class="px-4 py-2 text-slate-400 text-right">
                                    <span class="bg-blue-100 text-blue-700 px-2 py-0.5 rounded text-[10px] font-bold">${dcaRemaining} DCA LEFT</span>
                                </td>
                            </tr>
                        `;
                    } else if (dcaRemaining === 0 && entryHistory.length > 0) {
                        // Position fully built message
                        subRowsContent += `
                            <tr class="sub-row-${p.symbol.replace(/\W/g, '_')} bg-slate-50/50 text-xs" style="display:none;">
                                <td class="px-4 py-2 border-l-4 border-slate-300"></td>
                                <td class="px-4 py-2 text-emerald-500 w-8">
                                    <i class="fa-solid fa-check-double"></i>
                                </td>
                                <td colspan="8" class="px-4 py-2 text-slate-500">
                                    Position fully built (${maxEntries}/${maxEntries} entries) - DCA complete
                                </td>
                            </tr>
                        `;
                    }

                    // TAKE PROFIT levels
                    tpLevels.forEach(tp => {
                        const gainColor = tp.gain > 0 ? 'text-emerald-600' : 'text-slate-500';
                        subRowsContent += `
                            <tr class="sub-row-${p.symbol.replace(/\W/g, '_')} bg-amber-50/30 text-xs" style="display:none;">
                                <td class="px-4 py-2 border-l-4 border-amber-500"></td>
                                <td class="px-4 py-2 text-amber-500 w-8">
                                    <i class="fa-solid fa-gift"></i>
                                </td>
                                <td class="px-4 py-2">
                                    <span class="font-bold text-amber-700">Take Profit ${tp.level}</span>
                                    <span class="text-slate-400 ml-2 text-[10px]">PENDING</span>
                                </td>
                                <td class="px-4 py-2 font-mono text-amber-700 font-bold text-right">${fmtMoney(tp.price, curDisplay)}</td>
                                <td class="px-4 py-2 font-mono ${gainColor}">
                                    <div>+${tp.gain.toFixed(1)}% avg</div>
                                    <div class="text-[10px] text-slate-400">${(currentPrice > 0 ? (tp.price - currentPrice) / currentPrice * 100 : 0).toFixed(1)}% curr</div>
                                </td>
                                <td colspan="4" class="px-4 py-2 text-slate-400 text-right">
                                    <span class="bg-amber-100 text-amber-700 px-2 py-0.5 rounded text-[10px] font-bold">SELL ${fmtNum(Math.round(p.shares * (tp.pct / 100)))} @ ${fmtMoney(tp.price, curDisplay)} (${tp.pct}%)</span>
                                </td>
                            </tr>
                        `;
                    });

                    // STOP LOSS (Risk Management - always at bottom)
                    if (sl > 0) {
                        const riskPctColor = slPct < -10 ? 'text-rose-500' : 'text-amber-500';
                        subRowsContent += `
                            <tr class="sub-row-${p.symbol.replace(/\W/g, '_')} bg-rose-50/40 text-xs" style="display:none;">
                                <td class="px-4 py-2 border-l-4 border-rose-500"></td>
                                <td class="px-4 py-2 text-rose-500 w-8">
                                    <i class="fa-solid fa-shield-halved"></i>
                                </td>
                                <td class="px-4 py-2">
                                    <span class="font-bold text-rose-700">Stop Loss</span>
                                    <span class="text-slate-400 ml-2 text-[10px]">TRAILING</span>
                                </td>
                                <td class="px-4 py-2 font-mono text-rose-700 font-bold text-right">${fmtMoney(sl, curDisplay)}</td>
                                <td class="px-4 py-2 font-mono ${riskPctColor}">
                                    <div>${slPct.toFixed(1)}% avg</div>
                                    <div class="text-[10px] text-slate-400">${(currentPrice > 0 ? (sl - currentPrice) / currentPrice * 100 : 0).toFixed(1)}% curr</div>
                                </td>
                                <td colspan="4" class="px-4 py-2 text-slate-400 text-right">
                                    <span class="bg-rose-100 text-rose-700 px-2 py-0.5 rounded text-[10px] font-bold">EXIT ${fmtNum(p.shares)} @ ${fmtMoney(sl, curDisplay)}</span>
                                </td>
                            </tr>
                        `;
                    }

                    // Inject content
                    if (subRowsContent) {
                        tr.insertAdjacentHTML('afterend', subRowsContent);
                    }
                }
            });
        }
        const HIGH_BETA_THEMES = {
            "SEMICONDUCTOR": ["AMD", "NVDA", "MU", "AVGO", "TSM", "ASML", "QCOM", "INTC", "AMAT", "LRCX", "KLAC", "SNPS", "CDNS", "MRVL", "ON", "TER", "ASML.AS", "STM.PA", "IFX.DE", "BESI.AS", "SOIT.DE", "MPWR", "SWKS", "MCHP", "NXPI", "ADI", "XLNX", "WDC", "STX", "MXL", "SLAB", "CRUS", "SYNA", "QRVO", "LITE", "CIEN"],
            "BIOTECH": ["MRNA", "REGN", "VRTX", "BIIB", "GILD", "AMGN", "ILMN", "ALXN", "INCY", "BMRN", "SGEN", "IONS", "EXEL", "FOLD", "SRPT", "BLUE", "BNTX", "ARGX.BR", "UMI.BR", "VLA.PA", "DBV.PA", "NBIX", "HALO", "PTCT", "RARE", "LGND", "RGNX", "TECH", "ARWR"],
            "CRYPTO_PROXY": ["MSTR", "COIN", "MARA", "RIOT", "CLSK", "HOOD", "SQ", "PYPL", "IREN", "CIFR", "WULF", "HUT", "BITF", "ARBK", "XBTE.DE", "BTCE.DE", "21XB.DE", "VBTC.DE", "ETHw.DE"],
            "EV_TECH": ["TSLA", "RIVN", "LCID", "NIO", "XPEV", "LI", "FSR", "NKLA", "GOEV", "ARVL", "RIDE", "CHPT", "BLNK", "QS", "VOW3.DE", "BMW.DE", "MBG.DE", "RNO.PA", "PAH3.DE", "STLA.MI"],
            "AI_CLOUD": ["MSFT", "GOOGL", "GOOG", "META", "AMZN", "ORCL", "CRM", "NOW", "SNOW", "DDOG", "NET", "CRWD", "ZS", "OKTA", "PLTR", "AI", "SAP.DE", "CAP.PA", "DSY.PA", "NEM.DE"],
            "GOLD_MINERS": ["NEM", "GOLD", "AEM", "KGC", "FNV", "WPM", "ABX", "AU", "RGLD", "HL", "BTG", "EGO", "AGI", "PAAS", "CDE", "NGD", "IAG", "HMY", "SBSW", "DRD", "GFI", "SA", "EQX", "OR", "VZLA", "SVM", "MAG", "GPL", "ORLA", "FSM", "AG", "ASM", "SSRM", "NFG", "IOSP", "SCCO", "FCX", "TECK", "ALB", "SQM", "LAC"],
            "ENERGY": ["XOM", "CVX", "COP", "SLB", "HAL", "OXY", "EOG", "PXD", "MPC", "TTE.PA", "SHELL.AS", "BP.L", "ENI.MI", "REP.MC", "EQNR.OL", "GALP.LS", "VLO", "PSX", "DVN", "FANG", "HES", "MRO", "APA", "OVV", "CNQ", "SU", "IMO", "TRP", "ENB", "WES", "DTM", "LNG"],
            "FINTECH": ["V", "MA", "PYPL", "SQ", "AFRM", "SOFI", "UPST", "LC", "NU", "HOOD", "COIN", "ADYEN.AS", "WLN.PA", "NEXI.MI"],
            "LUXURY": ["MC.PA", "RMS.PA", "KER.PA", "OR.PA", "CDI.PA", "RI.PA", "MONC.MI", "CFR.SW", "UHR.SW", "RACE.MI", "BRBY.L"],
            "SOLAR_CLEAN": ["ENPH", "SEDG", "FSLR", "RUN", "NOVA", "CSIQ", "JKS", "DQ", "MAXN", "SHLS", "ARRY"],
            "DEFENSE_AEROSPACE": ["LMT", "RTX", "BA", "NOC", "GD", "LHX", "HWM", "TDG", "TXT", "AIR.PA", "SAF.PA", "RHM.DE", "HENS.DE", "MTX.DE", "BA.L", "LDO.MI", "HO.PA", "DAS.PA", "AXON", "LDOS", "SAIC"]
        };
        const STABLE_THEMES = {
            "UTILITIES": ["NEE", "DUK", "SO", "D", "AEP", "EXC", "SRE", "PEG", "XEL", "ENG.PA", "ENEL.MI", "IBE.MC", "EOAN.DE", "RWE.DE", "NG.L", "SSE.L", "ED", "ES", "FE", "EIX", "PPL", "WEC", "CNP", "AWK"],
            "CONSUMER_STAPLES": ["PG", "KO", "PEP", "WMT", "COST", "PM", "MO", "MDLZ", "CL", "NESN.SW", "ULVR.L", "OR.PA", "BN.PA", "HEI.DE", "BEI.DE", "GIS", "K", "HSY", "CPB", "SJM", "CAG", "TAP", "TSN"],
            "HEALTHCARE": ["JNJ", "UNH", "PFE", "ABBV", "TMO", "ABT", "DHR", "BMY", "LLY", "SAN.PA", "NOVN.SW", "ROG.SW", "AZN.L", "GSK.L", "BAYN.DE", "MRK.DE", "AMGN", "GILD", "CVS", "CI", "HUM", "BSX", "MDT"],
            "TELECOM": ["T", "VZ", "TMUS", "CHTR", "CMCSA", "DIS", "ORA.PA", "DTE.DE", "VOD.L", "TEF.MC", "KPN.AS"],
            "REAL_ESTATE": ["AMT", "PLD", "CCI", "EQIX", "PSA", "WELL", "DLR", "SPG", "O", "URW.AS", "VNA.DE", "LEG.DE", "LAND.L", "GEC.PA", "VICI", "AVB", "EQR", "INVH", "MAA"]
        };

        function getThemeForSymbol(sym) {
            for (let t in HIGH_BETA_THEMES) if (HIGH_BETA_THEMES[t].includes(sym)) return t;
            for (let t in STABLE_THEMES) if (STABLE_THEMES[t].includes(sym)) return t;
            return 'Other';
        }

        function getAssetType(p) {
            const sym = p.symbol || '';
            const ac = (p.asset_class || p.ac || '').toUpperCase();

            if (ac === 'CRYPTO' || sym.includes('-USD') || sym.includes('BTC') || sym.includes('ETH')) return 'Crypto';
            if (sym.includes('GOLD') || sym.includes('GC=F') || sym.includes('SI=F') || sym.includes('GLD') || sym.includes('SLV')) return 'Metals';
            if (sym.includes('CL=F') || sym.includes('OIL') || sym.includes('XOP') || sym.includes('XLE')) return 'Crude/Energy';

            const theme = getThemeForSymbol(sym);
            if (theme === 'SEMICONDUCTOR' || theme === 'AI_CLOUD' || theme === 'CLOUD_SAAS') return 'AI / Tech';
            if (theme === 'BIOTECH' || theme === 'HEALTHCARE') return 'Healthcare';
            if (theme === 'GOLD_MINERS') return 'Metals (Mining)';

            if (ac === 'ETF' || ['SPY', 'QQQ', 'IWM', 'DIA'].includes(sym)) return 'Market Indices';

            return 'Stocks';
        }

        function updateAllocChart(snap, fx) {
            updateBreakdownCharts(snap, fx);
        }

        function updateBreakdownCharts(snap, fx) {
            const positions = snap.positions || [];
            if (positions.length === 0) return;

            // 1. Sector
            renderPieChart('sector-breakdown', positions, (p) => p.sector || 'Other');
            // 2. Region (Market)
            renderPieChart('region-breakdown', positions, (p) => p.region || 'Global');
            // 2a. Country (Actual)
            renderPieChart('country-breakdown', positions, (p) => p.country || 'Unknown');
            // 2b. Currency
            renderPieChart('currency-breakdown', positions, (p) => p.native_currency || 'EUR');

            // 2c. Asset Class (Detailed)
            renderPieChart('asset-class-breakdown', positions, (p) => {
                let rc = p.raw_class || 'UNKNOWN';
                if (rc.includes('STOCKS')) return 'Stock';
                if (rc.includes('ETF_EQUITY')) return 'Stock';
                if (rc.includes('ETF_BOND') || rc.includes('ETF_FIXED_INCOME')) return 'Bond';
                if (rc.includes('GOLD')) return 'Gold';
                if (rc.includes('SILVER')) return 'Silver';
                if (rc.includes('BTC') || rc.includes('CRYPTO')) return 'Crypto';
                if (rc.includes('CRUDE') || rc.includes('ENERGY')) return 'Energy';
                if (rc.includes('ETF')) return 'ETF';
                if (rc.includes('FOREX')) return 'Forex';
                return rc;
            });

            // 3. Industry
            renderPieChart('industry-breakdown', positions, (p) => p.industry || 'Other');
            // 4. Asset Type
            // 4. Asset Type (Stock/ETF/Crypto/etc)
            renderPieChart('asset-type-breakdown', positions, (p) => p.asset_class || 'Stock');
            // 5. Theme
            renderPieChart('theme-breakdown', positions, (p) => {
                if (Array.isArray(p.theme) && p.theme.length > 0) return p.theme[0];
                if (p.themes && p.themes.length > 0) return p.themes[0];
                return 'Other';
            }, true);
            // 6. Market Cap (Disabled: Data missing)
            // renderPieChart('market-cap-breakdown', positions, (p) => p.marketCapCategory || 'Unknown');

            // Legacy Alloc Chart (Top 5) -> Now Pie/Doughnut as requested
            const canvas = el('allocChart');
            if (canvas) {
                let dataMap = [];
                positions.forEach(p => dataMap.push({ l: p.symbol, v: p.value * fx }));
                dataMap.sort((a, b) => b.v - a.v);

                let labels = [], values = [], colors = [];
                const pal = ['#3b82f6', '#8b5cf6', '#10b981', '#f59e0b', '#ef4444', '#06b6d4', '#eab308'];

                // Take top 6
                dataMap.slice(0, 6).forEach((d, i) => { labels.push(d.l); values.push(d.v); colors.push(pal[i % pal.length]); });

                // Group rest as Others
                if (dataMap.length > 6) {
                    labels.push('Others');
                    values.push(dataMap.slice(6).reduce((a, b) => a + b.v, 0));
                    colors.push('#cbd5e1');
                }

                // Add Cash (Clamped to 0 minimum for display, user reported weird negative cash)
                let displayCash = (snap.cash || 0) * fx;
                if (displayCash < 0) displayCash = 0;

                labels.push('Cash');
                values.push(displayCash);
                colors.push('#e2e8f0');

                if (charts.alloc) charts.alloc.destroy();
                charts.alloc = new Chart(canvas, {
                    type: 'doughnut',
                    data: {
                        labels: labels,
                        datasets: [{
                            data: values,
                            backgroundColor: colors,
                            borderWidth: 2,
                            borderColor: '#fff'
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: {
                                position: 'right',
                                labels: { boxWidth: 12, font: { size: 11 } }
                            },
                            tooltip: {
                                callbacks: {
                                    label: function (context) {
                                        const dataset = context.dataset.data;
                                        const total = dataset.reduce((a, b) => a + b, 0);
                                        const val = context.parsed || 0;
                                        const pct = (total > 0) ? ((val / total) * 100).toFixed(1) : '0.0';
                                        return `${context.label}: ${pct}% `;
                                    }
                                }
                            }
                        }
                    }
                });
            }
        }

        function renderPieChart(canvasId, positions, keyFn, isDoughnut = true) {
            const canvas = el(canvasId);
            if (!canvas) return;

            const groups = {};
            positions.forEach(p => {
                const k = keyFn(p);
                groups[k] = (groups[k] || 0) + (parseFloat(p.value) || 0);
            });

            const labels = Object.keys(groups).sort((a, b) => groups[b] - groups[a]).slice(0, 12);
            const data = labels.map(l => groups[l]);
            const total = data.reduce((a, b) => a + b, 0);
            const colors = ['#3b82f6', '#8b5cf6', '#10b981', '#f59e0b', '#ef4444', '#06b6d4', '#475569', '#1e293b', '#6d28d9', '#059669', '#d97706', '#dc2626'];

            if (charts[canvasId] && typeof charts[canvasId].destroy === 'function') {
                charts[canvasId].destroy();
                delete charts[canvasId];
            }
            charts[canvasId] = new Chart(canvas, {
                type: isDoughnut ? 'doughnut' : 'pie',
                data: {
                    labels: labels,
                    datasets: [{
                        data: data,
                        backgroundColor: colors.slice(0, labels.length),
                        borderWidth: 2,
                        borderColor: '#fff'
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { position: 'right', labels: { boxWidth: 12, font: { size: 10 } } },
                        tooltip: {
                            callbacks: {
                                label: function (ctx) {
                                    const val = ctx.parsed || 0;
                                    const pct = ((val / total) * 100).toFixed(1);
                                    return `${ctx.label}: ${pct}% `;
                                }
                            }
                        }
                    }
                }
            });
        }

        function getCountryFlag(symbol) {
            const sym = symbol || '';
            if (sym.endsWith('.PA')) return 'ðŸ‡«ðŸ‡·';
            if (sym.endsWith('.DE')) return 'ðŸ‡©ðŸ‡ª';
            if (sym.endsWith('.L')) return 'ðŸ‡¬ðŸ‡§';
            if (sym.endsWith('.AS')) return 'ðŸ‡³ðŸ‡±';
            if (sym.endsWith('.MI')) return 'ðŸ‡®ðŸ‡¹';
            if (sym.endsWith('.MC')) return 'ðŸ‡ªðŸ‡¸';
            if (sym.endsWith('.SW') || sym.endsWith('.VX')) return 'ðŸ‡¨ðŸ‡­';
            if (sym.endsWith('.HK')) return 'ðŸ‡­ðŸ‡°';
            if (sym.endsWith('.T') || sym.endsWith('.TYO')) return 'ðŸ‡¯ðŸ‡µ';
            if (sym.endsWith('.AX')) return 'ðŸ‡¦ðŸ‡º';
            if (sym.endsWith('.TO')) return 'ðŸ‡¨ðŸ‡¦';
            if (sym.endsWith('.BR')) return 'ðŸ‡§ðŸ‡ª';
            if (sym.endsWith('.WA')) return 'ðŸ‡µðŸ‡±';
            if (sym.endsWith('.AT')) return 'ðŸ‡¬ðŸ‡·';
            if (sym.includes('-USD') || sym.includes('BTC') || sym.includes('ETH')) return 'â‚¿';
            if (['GC=F', 'SI=F', 'CL=F', 'NG=F'].includes(sym)) return 'ðŸ¦';
            return 'ðŸ‡ºðŸ‡¸'; // Default to US
        }

        function getNativeCurrency(symbol) {
            const sym = symbol || '';
            if (sym.endsWith('.PA') || sym.endsWith('.DE') || sym.endsWith('.MI') || sym.endsWith('.MC') || sym.endsWith('.AS') || sym.endsWith('.VI') || sym.endsWith('.BR') || sym.endsWith('.LS') || sym.endsWith('.AT') || sym.endsWith('.HE')) return 'EUR';
            if (sym.endsWith('.L')) return 'GBP';
            if (sym.endsWith('.SW') || sym.endsWith('.VX')) return 'CHF';
            if (sym.endsWith('.HK')) return 'HKD';
            if (sym.endsWith('.WA')) return 'PLN';
            if (sym.endsWith('.NO') || sym.endsWith('.OL')) return 'NOK';
            if (sym.endsWith('.SE') || sym.endsWith('.ST')) return 'SEK';
            if (sym.endsWith('.DK') || sym.endsWith('.CO')) return 'DKK';
            return 'USD';
        }

        function _deprecated_updatePositions(snap, fx) {
            const tbody = el('pos-body');
            tbody.innerHTML = '';

            // Calculate Global Totals for Header Summary (Always Global for consistency)
            let sumUnrealizedGlobal = 0;
            if (snap.positions) snap.positions.forEach(p => sumUnrealizedGlobal += (p.unrealized_pnl || 0) * fx);
            const cashGlobal = (snap.cash || 0) * fx;
            const equityGlobal = (snap.equity || 0) * fx;

            // Update Header Indicators
            const sumPnlEl = el('pos-summary-pnl');
            const sumCashEl = el('pos-summary-cash');
            const sumEqEl = el('pos-summary-equity');

            if (sumPnlEl) {
                sumPnlEl.className = "flex flex-col";
                sumPnlEl.innerHTML = `<span class="text-[10px] text-slate-400 uppercase tracking-widest font-bold mb-0.5">Unrealized P&L</span><span class="${sumUnrealizedGlobal >= 0 ? "text-emerald-600" : "text-rose-600"} font-black text-lg">${fmtMoney(sumUnrealizedGlobal, STATE.currency)}</span>`;
            }
            if (sumCashEl) {
                sumCashEl.className = "flex flex-col";
                sumCashEl.innerHTML = `<span class="text-[10px] text-slate-400 uppercase tracking-widest font-bold mb-0.5">Cash</span><span class="text-slate-700 font-bold text-lg">${fmtMoney(cashGlobal, STATE.currency)}</span>`;
            }
            if (sumEqEl) {
                sumEqEl.className = "flex flex-col";
                sumEqEl.innerHTML = `<span class="text-[10px] text-slate-400 uppercase tracking-widest font-bold mb-0.5">Total Equity</span><span class="text-slate-900 font-black text-lg">${fmtMoney(equityGlobal, STATE.currency)}</span>`;
            }

            // Prepare Data
            const sorted = (snap.positions || []).slice().map(p => {
                const native = getSymbolCurrency(p.symbol, p.country || '');
                const isNativeMode = (STATE.posCurrencyMode === 'NATIVE' || STATE.posCurrencyMode === 'RAW');

                // Determine View Values
                // Determine View Values
                let viewPrice, viewCost, viewVal, viewPnL, curSym;
                const orders = (snap.pending_orders || []).filter(o => o.symbol === p.symbol);

                if (isNativeMode) {
                    const rate = getFX(snap.date, native);
                    viewPrice = (p.native_price !== undefined) ? p.native_price : (p.price * rate);
                    viewCost = (p.native_avg_cost !== undefined) ? p.native_avg_cost : (p.avg_cost * rate);
                    viewVal = (p.native_value !== undefined) ? p.native_value : (p.value * rate);
                    viewPnL = (p.native_unrealized_pnl !== undefined) ? p.native_unrealized_pnl : (p.unrealized_pnl * rate);
                    curSym = native;
                } else {
                    viewPrice = p.price * fx;
                    viewCost = p.avg_cost * fx;
                    viewVal = p.value * fx;
                    viewPnL = p.unrealized_pnl * fx;
                    curSym = STATE.currency;
                }

                // Collect Targets (SL & TP)
                const targets = orders.filter(o => {
                    const t = String(o.type).toUpperCase();
                    const a = String(o.action).toUpperCase();
                    return t.includes('STOP') || t.includes('LIMIT') || a.includes('PROFIT');
                }).map(o => {
                    const rate = isNativeMode ? getFX(snap.date, native) : fx;
                    const viewOrderPx = o.price * (isNativeMode ? 1.0 : fx); // Auditor prices are in base? No, auditor converted them if they came from aggregator.
                    // Wait, aggregator applied conversion_factor already.
                    // So co['price'] is already in Global Report Currency.
                    // If isNativeMode is on, we need to convert BACK to native or rely on original?
                    // Actually, auditor 'price' in co['price'] is now Global if aggregated.
                    // If we want Native, we divide by fx? 
                    // Let's assume order prices in the 'pending_orders' array follow the same currency as 'equity' and 'cash' in the global JSON.

                    let targetColor = 'slate';
                    let label = 'T';
                    const ot = String(o.type).toUpperCase();
                    if (ot.includes('STOP')) { targetColor = 'rose'; label = 'SL'; }
                    else if (ot.includes('LIMIT') || String(o.action).toUpperCase().includes('PROFIT')) { targetColor = 'emerald'; label = 'TP'; }

                    // Since Aggregator already converted co['price'] to Global Report Currency:
                    const valGlobal = o.price;
                    const displayPx = isNativeMode ? (valGlobal / fx * getFX(snap.date, native)) : (valGlobal * (STATE.currency === DATA.currency ? 1 : getFX(snap.date, STATE.currency)));

                    return `<div class="flex items-center justify-between gap-2 px-1 rounded bg-${targetColor}-50 border border-${targetColor}-100 text-${targetColor}-700 text-[9px] mb-0.5 last:mb-0">
                        <span class="font-bold">${label}</span>
                        <span>${fmtNum(o.shares || o.qty)}</span>
                        <span class="font-mono">@ ${fmtMoney(displayPx, curSym)}</span>
                    </div>`;
                }).join('');

                const valGlobal = p.value * fx;
                const pnlGlobal = p.unrealized_pnl * fx;

                return {
                    ...p,
                    _shares: p.sh || p.shares || 0,
                    _type: p.assetType || p.ac || 'Stock',
                    _price: viewPrice,
                    _cost: viewCost,
                    _value: viewVal,
                    _pnl: viewPnL,
                    _targets: targets || '<span class="text-slate-300">-</span>',
                    _curr: curSym,
                    _weight: (equityGlobal > 0) ? (valGlobal / equityGlobal * 100) : 0,
                    _impact: (equityGlobal > 0) ? (pnlGlobal / equityGlobal * 100) : 0
                };
            });

            // Sort
            sorted.sort((a, b) => {
                let va, vb;
                const col = STATE.sort.pos.col;
                if (col === 'symbol') { va = a.symbol; vb = b.symbol; }
                else if (col === 'type') { va = a._type; vb = b._type; }
                else if (col === 'shares') { va = a._shares; vb = b._shares; }
                else if (col === 'price') { va = a._price; vb = b._price; }
                else if (col === 'value') { va = a._value; vb = b._value; }
                else if (col === 'pnl') { va = a._pnl; vb = b._pnl; }
                else if (col === 'duration') { va = a.duration; vb = b.duration; }
                else if (col === 'weight') { va = a._weight; vb = b._weight; }
                else if (col === 'impact') { va = a._impact; vb = b._impact; }
                else if (col === 'avg_cost') { va = a._cost; vb = b._cost; }
                else { va = a._value; vb = b._value; }

                if (typeof va === 'string') return va.localeCompare(vb) * STATE.sort.pos.dir;
                return (va - vb) * STATE.sort.pos.dir;
            });


            sorted.forEach(p => {
                const tr = document.createElement('tr');
                tr.className = "hover:bg-slate-50 transition-colors border-b border-slate-100 group";

                const pnlClass = p._pnl >= 0 ? "text-emerald-600 font-bold" : "text-rose-600 font-bold";
                const impactClass = p._impact >= 0 ? "text-emerald-600" : "text-rose-600";
                const flag = getCountryFlag(p.symbol);
                const yahooLink = `https://finance.yahoo.com/quote/${p.symbol}`;

                // Targets logic for Badge in main row (simplified) or count
                // We'll show the detailed sub-rows instead. 
                // Just visually indicate if active orders exist? 
                const hasOrders = (p._targets && p._targets.length > 0 && p._targets !== '<span class="text-slate-300">-</span>');

                tr.innerHTML = `
                    <td class="px-3 py-1.5 text-slate-700">
                        <div class="flex items-center gap-2">
                            <span class="text-base opacity-80">${flag}</span>
                            <a href="${yahooLink}" target="_blank" class="hover:text-blue-600 hover:underline text-slate-900">${p.symbol}</a>
                        </div>
                    </td>
                    <td class="px-3 py-1.5 text-right font-mono text-xs text-slate-600">${fmtNum(p._shares)}</td>
                    <td class="px-3 py-1.5 text-right font-mono text-xs text-slate-500">${fmtMoney(p._cost, p._curr)}</td>
                    <td class="px-3 py-1.5 text-right font-mono text-xs text-slate-900">${fmtMoney(p._price, p._curr)}</td>
                    <td class="px-3 py-1.5 text-center px-1">
                        ${hasOrders ? '<span class="text-[10px] bg-slate-100 text-slate-500 px-1 py-0.5 rounded"><i class="fa-solid fa-list-check mr-1"></i>Active</span>' : '<span class="text-slate-300">-</span>'}
                    </td>
                    <td class="px-3 py-1.5 text-right font-mono text-xs text-slate-800">${fmtMoney(p._value, p._curr)}</td>
                    <td class="px-3 py-1.5 text-right font-mono text-xs ${pnlClass}">${fmtMoney(p._pnl, p._curr)}</td>
                    <td class="px-3 py-1.5 text-right font-mono text-xs text-slate-500">${fmtDuration(p.duration, CURRENT_PERIOD)}</td>
                    <td class="px-3 py-1.5 text-right font-mono text-xs text-slate-600">${p._weight.toFixed(1)}%</td>
                    <td class="px-3 py-1.5 text-right font-mono text-xs ${impactClass}">${p._impact > 0 ? '+' : ''}${p._impact.toFixed(2)}%</td>
                `;
                tbody.appendChild(tr);

                // Sub-rows for Active Orders (Targets)
                if (hasOrders) {
                    // Extract raw HTML from _targets (which was badges) isn't ideal if we want rows.
                    // Let's re-parse or use the raw 'orders' array if we had it.
                    // We constructed _targets as HTML string.
                    // Better approach: Re-query orders here locally or pass them.
                    // The _targets field in 'p' is already a joined HTML string of badges.
                    // User wants "sub lines".
                    // Let's parse the original snap.pending_orders again for this symbol.
                    const subOrders = (snap.pending_orders || []).filter(o => o.symbol === p.symbol && (String(o.type).includes('STOP') || String(o.type).includes('LIMIT') || String(o.action).includes('PROFIT')));

                    subOrders.forEach(o => {
                        const ot = String(o.type).toUpperCase();
                        let typeLabel = 'TARGET';
                        let rowBg = 'bg-slate-50/50';
                        let typeColor = 'text-slate-500';

                        if (ot.includes('STOP')) { typeLabel = 'STOP LOSS'; rowBg = 'bg-rose-50/30'; typeColor = 'text-rose-600'; }
                        else if (ot.includes('LIMIT') || String(o.action).toUpperCase().includes('PROFIT')) { typeLabel = 'TAKE PROFIT'; rowBg = 'bg-emerald-50/30'; typeColor = 'text-emerald-600'; }

                        // Price Conversion for View
                        const isNativeMode = (STATE.posCurrencyMode === 'NATIVE' || STATE.posCurrencyMode === 'RAW');
                        const native = getSymbolCurrency(p.symbol, p.country);
                        const rate = isNativeMode ? getFX(snap.date, native) : fx;
                        // Aggregator converted price to Global.
                        // If Native Mode: Convert Global -> Native.
                        // Order Price (Global) / FX(Global) * FX(Native) ??
                        // Data from aggregator: price is in Report Currency.
                        // Native Mode needs Native Price.
                        const valGlobal = o.price;
                        const fxGlobal = getFX(snap.date, STATE.currency); // conversion factor used by aggregator?
                        // Wait, aggregator used specific rates.
                        // We can reverse engineer or just use currency logic:
                        // If we are in Native Mode, we want the price in 'native' currency.
                        // valGlobal is in Report Currency.
                        // Native = valGlobal / FX(Report) * FX(Native).

                        const curDisplay = isNativeMode ? native : STATE.currency;
                        const fxReport = getFX(snap.date, STATE.currency);
                        const fxNative = getFX(snap.date, native);

                        // Avoid div by zero
                        const priceDisplay = (STATE.currency === DATA.currency)
                            ? (isNativeMode ? valGlobal * fxNative : valGlobal)
                            : (isNativeMode ? (valGlobal / fxReport * fxNative) : valGlobal);

                        const subTr = document.createElement('tr');
                        subTr.className = `${rowBg} border-b border-slate-50`;
                        subTr.innerHTML = `
                            <td class="px-3 py-1 text-right border-r border-slate-100" colspan="4">
                                <span class="text-[9px] font-bold uppercase tracking-wider ${typeColor} mr-2">${typeLabel}</span>
                            </td>
                            <td class="px-3 py-1 text-center">
                                <span class="text-xs font-mono text-slate-500">${fmtNum(o.shares || o.qty)}</span>
                            </td>
                            <td class="px-3 py-1 text-right">
                                <span class="text-xs font-mono font-bold ${typeColor}">${fmtMoney(priceDisplay, curDisplay)}</span>
                            </td>
                            <td colspan="4"></td>
                        `;
                        tbody.appendChild(subTr);
                    });
                }
            });
        }

        function updateOrders(snap, fx) {
            const tbody = el('orders-body');
            const dateLabel = el('orders-date-label');
            tbody.innerHTML = '';
            const date = snap.date;
            if (dateLabel) dateLabel.innerText = fmtDate(date);

            // Conditional Time Column
            const isIntraday = ['24h', '48h'].includes(CURRENT_PERIOD);
            const timeColHeader = el('col-orders-time');
            if (timeColHeader) timeColHeader.style.display = isIntraday ? '' : 'none';

            // Get pending orders (excluding SELL STOP which are shown in positions)
            const pendingOrders = (snap.pending_orders || []).filter(o => o.type !== 'SELL STOP');

            // Get trades executed on this date (or same day for intraday mode)
            const snapDatePart = getDatePart(date);
            const shortPeriods = ['24h', '48h', '1w', '2w'];
            const dayTrades = TRADES.filter(t => {
                const tradeDatePart = getDatePart(t.Date);
                if (shortPeriods.includes(CURRENT_PERIOD)) {
                    // For intraday, match same day OR exact timestamp
                    return tradeDatePart === snapDatePart || t.Date === date;
                } else {
                    // For daily mode, match same day
                    return tradeDatePart === snapDatePart;
                }
            });

            if (pendingOrders.length === 0 && dayTrades.length === 0) {
                tbody.innerHTML = `<tr><td colspan="5" class="px-4 py-4 text-center text-slate-400 italic">No activity on this date</td></tr>`;
                return;
            }

            // Combine into a sortable list
            let items = [];

            pendingOrders.forEach(o => {
                const created = o.date;
                let dur = '-';
                let durVal = -1;
                if (created) {
                    // Normalize dates to YYYY-MM-DD to avoid timezone/time part issues
                    const s = created.split('T')[0];
                    const e = date.split('T')[0];

                    const startMs = new Date(s).getTime();
                    const endMs = new Date(e).getTime();
                    if (!isNaN(startMs) && !isNaN(endMs)) {
                        durVal = Math.round((endMs - startMs) / 86400000);
                        dur = durVal + 'd';
                    }
                }

                // TWAP Display
                let typeStr = `${o.action} ${o.type}`;
                if (o.is_split_order) {
                    typeStr += ` (Split ${o.split_index + 1}/${o.split_total_parts})`;
                }

                items.push({
                    t: 'pending',
                    symbol: o.symbol,
                    type: typeStr,
                    qty: o.shares,
                    price: o.price,
                    status: o.status || 'PENDING',
                    created: created || '-',
                    duration: dur,
                    _durVal: durVal,
                    raw: o
                });
            });

            // Get set of pending order keys (symbol+date+type) to avoid duplicates
            const pendingKeys = new Set(pendingOrders.map(o => `${o.symbol}_${o.date}_${o.type}`));

            dayTrades.forEach(t => {
                // Skip trades that are PENDING status AND already in pending_orders
                const tradeStatus = t.Status || 'FILLED';
                const tradeKey = `${t.Symbol}_${t.Date}_${t.Type}`;
                if (tradeStatus.toUpperCase() === 'PENDING' && pendingKeys.has(tradeKey)) {
                    return; // Skip duplicate pending
                }

                // Creation Date logic
                let created = t.creation_date || t.Date.substring(0, 10);
                if (t.Action && t.Action.includes('SELL') && !t.creation_date) {
                    // If SELL without creation date, it might be immediate.
                    // But effectively created today.
                    created = t.Date.substring(0, 10);
                }

                let dur = '-';
                let durVal = -1;
                if (created) {
                    // Normalize dates to YYYY-MM-DD
                    const cStr = created.split('T')[0];
                    const eStr = date.split('T')[0];

                    const cDate = new Date(cStr).getTime();
                    const eDate = new Date(eStr).getTime();
                    if (!isNaN(cDate) && !isNaN(eDate)) {
                        durVal = Math.round((eDate - cDate) / 86400000);
                        dur = durVal + 'd';
                    }
                }

                items.push({
                    t: 'filled',
                    symbol: t.Symbol,
                    type: t.Action,
                    qty: t.Shares,
                    price: parseFloat(t.Price),
                    status: tradeStatus,
                    created: created,
                    duration: dur,
                    _durVal: durVal,
                    raw: t
                });
            });

            // We don't have separate state sort for orders yet, adding basic local sort or relying on order?
            // Since user requested sortable, let's assume table header onclicks are not present yet for 'orders' table in init?
            // Actually, the HTML doesn't call toggleSort('orders', ...). 
            // Implementing toggleSort support requires a state key.
            if (!STATE.sort.orders) STATE.sort.orders = { col: 'symbol', dir: 1 };

            const s = STATE.sort.orders;
            items.sort((a, b) => {
                let va = a[s.col];
                let vb = b[s.col];
                if (va === undefined) va = '';
                if (vb === undefined) vb = '';

                if (s.col === 'duration') {
                    va = a._durVal;
                    vb = b._durVal;
                    return (va - vb) * s.dir;
                }

                if (typeof va === 'string') return va.localeCompare(vb) * s.dir;
                return (va - vb) * s.dir;
            });


            // Detect round-trips (same symbol bought and sold on same date)
            const symbolActions = {};
            dayTrades.forEach(t => {
                if (!symbolActions[t.Symbol]) symbolActions[t.Symbol] = [];
                symbolActions[t.Symbol].push(t.Action);
            });
            const roundTripSymbols = new Set();
            for (const sym in symbolActions) {
                const actions = symbolActions[sym];
                if (actions.some(a => a.includes('BUY')) && actions.some(a => a.includes('SELL') || a === 'STOP' || a === 'CLOSE')) {
                    roundTripSymbols.add(sym);
                }
            }

            items.forEach(item => {
                const o = item.t === 'pending' ? item.raw : null;
                const t = item.t === 'filled' ? item.raw : null;

                const flag = getCountryFlag(o ? o.symbol : t.Symbol);
                const isRoundTrip = roundTripSymbols.has(o ? o.symbol : t.Symbol);
                const roundTripBadge = isRoundTrip ? ' <span class="bg-purple-100 text-purple-700 text-[8px] px-1 py-0.5 rounded ml-1 font-bold">RT</span>' : '';

                let rowHtml = '';
                const formatAction = (act) => {
                    if (!act) return '-';
                    return act.replace(/_/g, ' ')
                        .replace(' FILLED', '')
                        .replace(' CANCELED', '')
                        .replace(' REJECTED', '')
                        .trim();
                };

                if (item.t === 'pending') {
                    const rowColor = o.action.includes('BUY') ? 'text-blue-600' : 'text-slate-600';
                    const statusColor = o.status === 'REJECTED' || o.status === 'CANCELED' ? 'text-rose-500' : 'text-blue-500';
                    const statusIcon = o.status === 'REJECTED' ? 'fa-circle-xmark' : (o.status === 'FILLED' ? 'fa-check-double' : 'fa-clock');
                    const status = o.status || 'PENDING';

                    // Gap/Diff Calculation
                    let gapHtml = '-';
                    // Ensure we have valid prices
                    const curP = parseFloat(o.current_price);
                    const limP = parseFloat(o.price);

                    if (!String(o.type).includes('MARKET') && curP > 0 && limP > 0) {
                        const diff = (limP - curP) / curP;
                        const diffPct = (diff * 100).toFixed(1) + '%';
                        const diffColor = diff > 0 ? 'text-emerald-500' : 'text-rose-500';
                        gapHtml = `<span class="${diffColor}">${diffPct}</span>`;
                    }

                    rowHtml = `
                        <tr class="hover:bg-slate-50 transition-colors border-b border-slate-50" title="${o.reason || ''}">
                            <td class="px-3 py-1.5 font-mono text-xs text-slate-400" style="${isIntraday ? '' : 'display:none'}">-</td>
                            <td class="px-3 py-1.5 text-slate-700">
                                <span class="mr-2 text-base opacity-80">${flag}</span>${o.symbol}${roundTripBadge}
                            </td>
                            <td class="px-3 py-1.5 text-[10px] uppercase font-mono ${rowColor}">${formatAction(item.type)}</td>
                            <td class="px-3 py-1.5 text-right font-mono text-xs text-slate-600">${o.shares}</td>
                            <td class="px-3 py-1.5 text-right font-mono text-xs text-slate-700">${fmtMoney(o.price * fx)}</td>
                            <td class="px-3 py-1.5 text-right font-mono text-xs">${gapHtml}</td>
                            <td class="px-3 py-1.5 text-right ${statusColor} text-[10px] uppercase font-bold"><i class="fa-solid ${statusIcon} mr-1"></i> ${status}</td>
                            <td class="px-3 py-1.5 text-right font-mono text-xs text-slate-500">${item.created}</td>
                            <td class="px-3 py-1.5 text-right font-mono text-xs text-slate-500">${item.duration}</td>
                        </tr>`;
                } else {
                    const actionColor = t.Action.includes('BUY') ? 'text-blue-600' : 'text-slate-600';
                    const statusColor = 'text-emerald-600';
                    const tradeFx = getFX(t.Date, STATE.currency);
                    const rowBg = isRoundTrip ? 'bg-purple-50 hover:bg-purple-100' : 'hover:bg-slate-50';
                    const timeStr = t.Date.includes('T') ? t.Date.split('T')[1].substring(0, 5) : (t.Date.includes(' ') ? t.Date.split(' ')[1].substring(0, 5) : '-');

                    // P&L and Impact for Filled Orders
                    let pnlHtml = '-';
                    if (t.Action.includes('SELL') && t.PnL) {
                        const pnlVal = parseFloat(t.PnL) * tradeFx;
                        const proceeds = parseFloat(t.Value || 0) * tradeFx;
                        const cost = proceeds - pnlVal;
                        let impactPct = 0;
                        if (cost !== 0) impactPct = (pnlVal / cost) * 100;

                        const pnlColor = pnlVal >= 0 ? 'text-emerald-600' : 'text-rose-600';
                        pnlHtml = `<div class="flex flex-col items-end leading-tight">
                                        <span class="${pnlColor} font-bold">${fmtMoney(pnlVal)}</span>
                                        <span class="text-[9px] text-slate-400">${impactPct > 0 ? '+' : ''}${impactPct.toFixed(1)}%</span>
                                    </div>`;
                    }

                    // Tooltip Logic
                    const reason = t.Reason || '';
                    const toolTip = reason ? `<span class="group relative cursor-help ml-1">
                                                <i class="fa-solid fa-circle-question text-slate-300 hover:text-blue-400 text-[10px]"></i>
                                                <span class="pointer-events-none absolute bottom-full left-1/2 -translate-x-1/2 mb-2 w-max max-w-[200px] bg-slate-800 text-white text-[10px] rounded px-2 py-1 opacity-0 group-hover:opacity-100 transition-opacity z-50 shadow-lg">
                                                    ${reason}
                                                </span>
                                              </span>` : '';


                    rowHtml = `
                        <tr class="${rowBg} transition-colors border-b border-slate-50">
                            <td class="px-3 py-1.5 font-mono text-xs text-slate-400" style="${isIntraday ? '' : 'display:none'}">${timeStr}</td>
                            <td class="px-3 py-1.5 text-slate-700">
                                <div class="flex items-center">
                                    <span class="mr-2 text-base opacity-80">${flag}</span>${t.Symbol}${roundTripBadge}
                                    ${toolTip}
                                </div>
                            </td>
                            <td class="px-3 py-1.5 text-[10px] uppercase font-mono ${actionColor}">${formatAction(t.Action)}</td>
                            <td class="px-3 py-1.5 text-right font-mono text-xs text-slate-600">${t.Shares}</td>
                            <td class="px-3 py-1.5 text-right font-mono text-xs text-slate-700">${fmtMoney(parseFloat(t.Price) * tradeFx)}</td>
                            <td class="px-3 py-1.5 text-right text-xs font-mono">${pnlHtml}</td>
                            <td class="px-3 py-1.5 text-right ${statusColor} text-[10px] uppercase"><i class="fa-solid fa-check mr-1"></i> FILLED</td>
                            <td class="px-3 py-1.5 text-right font-mono text-xs text-slate-500">${item.created}</td>
                            <td class="px-3 py-1.5 text-right font-mono text-xs text-slate-500">${item.duration}</td>
                        </tr>`;
                }
                tbody.innerHTML += rowHtml;
            });
        }

        function updateRisk(snap) {
            // Calculate VaR 99% from last 60 days of returns
            const idx = STATE.idx || (DATA.history.length - 1);
            const lookback = Math.min(60, idx);
            const returns = [];
            for (let i = idx - lookback + 1; i <= idx; i++) {
                if (i > 0) {
                    const prev = DATA.history[i - 1].equity;
                    const curr = DATA.history[i].equity;
                    if (prev > 0) returns.push((curr - prev) / prev);
                }
            }

            // VaR 99%: sort returns, take 1st percentile
            returns.sort((a, b) => a - b);
            const varIdx = Math.floor(returns.length * 0.01);
            const var99 = returns[varIdx] || -0.02;
            el('risk-var').innerText = (var99 * 100).toFixed(2) + '%';

            // Calculate Beta using correlation with benchmark
            let beta = 0.85; // Default
            if (BENCH && BENCH['S&P 500']) {
                // Simplified beta calculation
                const vol = returns.length > 0 ? Math.sqrt(returns.reduce((a, r) => a + r * r, 0) / returns.length) * Math.sqrt(252) : 0.15;
                beta = Math.min(1.5, Math.max(0.3, vol / 0.18)); // Normalize to market vol ~18%
            }
            el('risk-beta').innerText = beta.toFixed(2);
            el('risk-beta-val').innerText = beta.toFixed(2);


            // Delegate chart updates to centralized function
            const fx = getFX(snap.date, STATE.currency);
            updateBreakdownCharts(snap, fx);
        }

        function updateStressTest(drop) {
            const idx = STATE.idx || (DATA.history.length - 1);
            const snap = DATA.history[idx];
            if (!snap) return;

            const beta = STATE.beta || 0.85;
            const pfDrop = (drop / 100) * beta;
            const fx = getFX(snap.date, STATE.currency);

            const equity = snap.equity * fx;
            const loss = equity * pfDrop;

            el('stress-slider-val').innerText = "-" + drop + "% Drop";
            el('stress-impact-pct').innerText = "-" + (pfDrop * 100).toFixed(2) + "%";
            el('stress-impact-val').innerText = "-" + fmtMoney(loss);
        }

        function updateTradeIdeas(snap) {
            const tbody = document.getElementById('ideas-review-body');
            if (!tbody) return;
            tbody.innerHTML = '';

            // Use LAST available date (end of history) - independent of Time Machine
            const lastSnap = DATA.history && DATA.history.length > 0 ? DATA.history[DATA.history.length - 1] : snap;
            const date = lastSnap.date;
            const fx = getFX(date, STATE.currency);

            // Filter Recommendations: Last 30 days from END of history (not Time Machine)
            const snapDateObj = new Date(date.replace(' ', 'T'));
            const lookback = new Date(snapDateObj);
            lookback.setDate(lookback.getDate() - 30);
            const limitStr = lookback.toISOString().split('T')[0];
            const snapStr = date.split('T')[0];

            let ideas = RECOMMENDATIONS.filter(r => {
                const rDate = r.Date.split('T')[0];
                return rDate >= limitStr && rDate <= snapStr;
            });

            // DEDUPE: Keep only the latest occurrence per Symbol
            const latestBySymbol = {};
            ideas.forEach(r => {
                const sym = r.Symbol;
                if (!latestBySymbol[sym] || r.Date > latestBySymbol[sym].Date) {
                    latestBySymbol[sym] = r;
                }
            });
            ideas = Object.values(latestBySymbol);

            // Show Bad Entries Filter
            const showBad = document.getElementById('show-bad-entries');
            if (showBad && !showBad.checked) {
                ideas = ideas.filter(r => {
                    const entry = parseFloat(r.Price || 0);
                    const pos = lastSnap.positions ? lastSnap.positions.find(p => p.symbol === r.Symbol) : null;

                    // Convert pos.price from EUR to native currency for comparison
                    let currentPrice = entry;
                    if (pos) {
                        const native = getSymbolCurrency(r.Symbol);
                        if (native === 'EUR') {
                            currentPrice = pos.price;
                        } else {
                            const fxRate = getFX(lastSnap.date, native);
                            currentPrice = pos.price * fxRate;
                        }
                    }

                    return currentPrice >= entry;
                });
            }

            // Update count
            const countEl = document.getElementById('ideas-count');
            if (countEl) countEl.innerText = `${ideas.length} signals`;

            // Sort
            ideas.sort((a, b) => {
                let va, vb;
                const col = STATE.sort.ideas.col;
                const dir = STATE.sort.ideas.dir;

                if (col === 'Date') { va = a.Date; vb = b.Date; }
                else if (col === 'Symbol') { va = a.Symbol; vb = b.Symbol; }
                else if (col === 'Price') { va = parseFloat(a.Price || 0); vb = parseFloat(b.Price || 0); }
                else if (col === 'Perf') {
                    // Convert position prices from EUR to native currency
                    const pa = lastSnap.positions ? lastSnap.positions.find(pos => pos.symbol === a.Symbol) : null;
                    let curra = parseFloat(a.Price || 0);
                    if (pa) {
                        const nativeA = getSymbolCurrency(a.Symbol);
                        if (nativeA === 'EUR') {
                            curra = pa.price;
                        } else {
                            curra = pa.price * getFX(lastSnap.date, nativeA);
                        }
                    }
                    va = (curra - parseFloat(a.Price || 0)) / parseFloat(a.Price || 1);

                    const pb = lastSnap.positions ? lastSnap.positions.find(pos => pos.symbol === b.Symbol) : null;
                    let currb = parseFloat(b.Price || 0);
                    if (pb) {
                        const nativeB = getSymbolCurrency(b.Symbol);
                        if (nativeB === 'EUR') {
                            currb = pb.price;
                        } else {
                            currb = pb.price * getFX(lastSnap.date, nativeB);
                        }
                    }
                    vb = (currb - parseFloat(b.Price || 0)) / parseFloat(b.Price || 1);
                }
                else if (col === 'RR') {
                    const getRR = (item) => {
                        const pos = lastSnap.positions ? lastSnap.positions.find(p => p.symbol === item.Symbol) : null;

                        // Convert pos.price from EUR to native currency
                        let curr = parseFloat(item.Price || 0);
                        if (pos) {
                            const native = getSymbolCurrency(item.Symbol);
                            if (native === 'EUR') {
                                curr = pos.price;
                            } else {
                                curr = pos.price * getFX(lastSnap.date, native);
                            }
                        }

                        const sl = parseFloat(item.StopLoss || 0);
                        const tp = parseFloat(item.TakeProfit || 0);
                        if (tp > 0 && sl > 0 && curr > sl && tp > curr) {
                            return (tp - curr) / (curr - sl);
                        }
                        return -1;
                    };
                    va = getRR(a);
                    vb = getRR(b);
                }

                if (va < vb) return -1 * dir;
                if (va > vb) return 1 * dir;
                return 0;
            });

            ideas.forEach(r => {
                const rowId = `idea-${r.Symbol.replace(/\W/g, '_')}`;
                const entry = parseFloat(r.Price || 0);
                const sl = parseFloat(r.StopLoss || 0);
                const tp = parseFloat(r.TakeProfit || 0);

                // Find Current Price from positions or use entry
                const pos = lastSnap.positions ? lastSnap.positions.find(p => p.symbol === r.Symbol) : null;

                // Convert price to native currency
                // pos.price is in EUR (portfolio currency)
                // entry is in native currency
                // We need to convert pos.price from EUR to native currency
                const native = getSymbolCurrency(r.Symbol);
                let currentPrice = entry; // Default to entry price

                if (pos) {
                    // pos.price is in EUR, need to convert to native
                    if (native === 'EUR') {
                        currentPrice = pos.price;
                    } else {
                        // Convert EUR -> Native using FX rate
                        const fxRate = getFX(lastSnap.date, native);
                        currentPrice = pos.price * fxRate;
                    }
                }

                // R:R from CURRENT PRICE (not entry): (TP - CurrentPrice) / (CurrentPrice - SL)
                let rr = 0;
                if (tp > 0 && sl > 0 && currentPrice > sl && tp > currentPrice) {
                    rr = (tp - currentPrice) / (currentPrice - sl);
                }

                // Perf % from entry
                const perf = entry > 0 ? (currentPrice - entry) / entry : 0;

                // Formatting
                const fmt = (v) => fmtMoney(v, native);
                const fmtP = (v) => (v >= 0 ? '+' : '') + (v * 100).toFixed(1) + '%';

                // Classes
                const perfClass = perf >= 0 ? 'text-emerald-600' : 'text-rose-600';

                // Main row
                const tr = document.createElement('tr');
                tr.className = "hover:bg-slate-50 transition-colors border-b border-slate-50 last:border-0 cursor-pointer";
                tr.setAttribute('onclick', `toggleSubRows('${rowId}')`);

                // Check if has setup details
                const reasonRaw = (r.Reason || '').trim();
                const hasDetails = reasonRaw.length > 0;

                tr.innerHTML = `
                    <td class="px-4 py-3 font-mono text-slate-500 text-xs cursor-pointer group">
                         <div class="flex items-center">
                            ${hasDetails ? '<div class="w-4 flex justify-center mr-2"><i id="chevron-' + rowId + '" class="fa-solid fa-chevron-right text-sm text-blue-400 group-hover:text-blue-600 transition-transform"></i></div>' : '<div class="w-4 mr-2"></div>'}
                            ${fmtDate(r.Date)}
                        </div>
                    </td>
                    <td class="px-4 py-3 font-medium text-slate-800 group" title="Click to view Setup Details">
                        <div class="flex items-center">
                            <span class="mr-2 text-base">${getCountryFlag(r.Symbol)}</span>
                            <a href="https://finance.yahoo.com/quote/${r.Symbol}" target="_blank" onclick="event.stopPropagation()" class="font-bold group-hover:text-blue-600 hover:underline transition-colors">${r.Symbol}</a>
                        </div>
                    </td>
                    <td class="px-4 py-3 text-right font-mono text-slate-600">${fmt(entry)}</td>
                    <td class="px-4 py-3 text-right font-mono">
                        <span class="text-slate-800 font-bold">${fmt(currentPrice)}</span>
                        <span class="text-xs ${perfClass} ml-1">(${fmtP(perf)})</span>
                    </td>
                    <td class="px-4 py-3 text-right font-mono text-rose-500">${sl > 0 ? fmt(sl) : '-'}</td>
                    <td class="px-4 py-3 text-right font-mono text-emerald-600">${tp > 0 ? fmt(tp) : '-'}</td>
                    <td class="px-4 py-3 text-center font-mono font-bold text-slate-700 bg-slate-50">${rr > 0 ? rr.toFixed(1) : '-'}</td>
                `;
                tbody.appendChild(tr);

                // Expandable sub-row with Setup details - FORMATTED AS CHECKLIST
                if (hasDetails) {
                    const subRow = document.createElement('tr');
                    subRow.className = `sub-row-${rowId} text-xs`;
                    subRow.style.display = 'none';

                    // Parse the reason string (format: "part1; part2; part3")
                    const parts = reasonRaw.split('; ');

                    // Map parts to emoji categories
                    // Map parts to emoji categories
                    const formatPart = (part) => {
                        const baseClass = "flex items-center gap-2 bg-white/20 px-3 py-2 rounded-lg";

                        // Score breakdown
                        if (part.includes('Score') && part.includes('=')) {
                            const match = part.match(/Score\s*([\d\.]+)/);
                            const score = match ? parseFloat(match[1]) : 0;
                            let explanation = "Standard technical setup meeting strategy criteria.";
                            if (score >= 100) explanation = "Exceptional high-conviction opportunity driven by reward potential.";
                            else if (score >= 50) explanation = "Strong setup with favorable risk/reward efficiency.";
                            else if (score >= 30) explanation = "Valid setup with moderate conviction.";
                            else explanation = "Speculative setup meeting minimum entry requirements.";

                            return `<div class="${baseClass}">
                                <span class="text-lg">ðŸ“Š</span>
                                <div class="flex flex-col leading-tight">
                                    <span class="font-bold">${part}</span>
                                    <span class="text-xs opacity-80 font-normal italic mt-0.5">${explanation}</span>
                                </div>
                            </div>`;
                        }
                        // Momentum
                        if (part.toLowerCase().includes('momentum')) {
                            const isStrong = part.includes('Strong');
                            const explanation = isStrong
                                ? "Persistent uptrend confirms bullish conviction."
                                : "Positive trend alignment supports long entry.";
                            return `<div class="${baseClass}">
                                <span class="text-lg">${isStrong ? 'ðŸš€' : 'ðŸ“ˆ'}</span>
                                <div class="flex flex-col leading-tight">
                                    <span class="font-bold">${part}</span>
                                    <span class="text-xs opacity-80 font-normal italic mt-0.5">${explanation}</span>
                                </div>
                            </div>`;
                        }
                        // RSI
                        if (part.includes('RSI')) {
                            const isOversold = part.includes('Oversold') || part.includes('Pullback');
                            const explanation = isOversold
                                ? "Entry on temporary weakness within an uptrend."
                                : "Momentum is healthy but not yet overextended.";
                            return `<div class="${baseClass}">
                                <span class="text-lg">${isOversold ? 'ðŸŽ¯' : 'âš¡'}</span>
                                <div class="flex flex-col leading-tight">
                                    <span class="font-bold">${part}</span>
                                    <span class="text-xs opacity-80 font-normal italic mt-0.5">${explanation}</span>
                                </div>
                            </div>`;
                        }
                        // Gap
                        if (part.includes('Gap')) {
                            const isUp = part.includes('+');
                            const explanation = isUp
                                ? "Price gap suggests strong buying urgency."
                                : "Gap down provides a discounted entry opportunity.";
                            return `<div class="${baseClass}">
                                <span class="text-lg">${isUp ? 'ðŸ”¼' : 'ðŸ”½'}</span>
                                <div class="flex flex-col leading-tight">
                                    <span class="font-bold">${part}</span>
                                    <span class="text-xs opacity-80 font-normal italic mt-0.5">${explanation}</span>
                                </div>
                            </div>`;
                        }
                        // Volatility/Risk
                        if (part.toLowerCase().includes('volatility') || part.includes('ATR')) {
                            const isLow = part.includes('Low');
                            const explanation = isLow
                                ? "Stable price action reduces stop-out risk."
                                : "Higher volatility requires wider stop distances.";
                            return `<div class="${baseClass}">
                                <span class="text-lg">${isLow ? 'ðŸ›¡ï¸' : 'âš ï¸'}</span>
                                <div class="flex flex-col leading-tight">
                                    <span class="font-bold">${part}</span>
                                    <span class="text-xs opacity-80 font-normal italic mt-0.5">${explanation}</span>
                                </div>
                            </div>`;
                        }
                        // Liquidity
                        if (part.includes('Liquid') || part.includes('volume') || part.includes('$')) {
                            const isThin = part.includes('Thin');
                            const explanation = isThin
                                ? "Caution: Execution slippage may occur."
                                : "High volume ensures easy trade execution.";
                            return `<div class="${baseClass}">
                                <span class="text-lg">${isThin ? 'ðŸ’§' : 'ðŸŒŠ'}</span>
                                <div class="flex flex-col leading-tight">
                                    <span class="font-bold">${part}</span>
                                    <span class="text-xs opacity-80 font-normal italic mt-0.5">${explanation}</span>
                                </div>
                            </div>`;
                        }
                        // Default
                        const explanation = "Criterion passed.";
                        return `<div class="${baseClass}">
                            <span class="text-lg">âœ…</span>
                            <div class="flex flex-col leading-tight">
                                <span class="font-bold">${part}</span>
                                <span class="text-xs opacity-80 font-normal italic mt-0.5">${explanation}</span>
                            </div>
                        </div>`;
                    };

                    const formattedParts = parts.map(formatPart).join('');

                    subRow.innerHTML = `
                         <td colspan="7" style="background:linear-gradient(135deg, #1e40af 0%, #3b82f6 100%); color:#f8fafc; padding:12px 16px;">
                            <div class="flex flex-col gap-3">
                                <div class="flex items-center gap-6 border-b border-blue-400/30 pb-2">
                                    <span class="uppercase tracking-wider font-bold"><i class="fa-solid fa-magnifying-glass-chart mr-2"></i>SIGNAL ANALYSIS</span>
                                    <span class="text-blue-200 text-xs">${r.Symbol} Strategy Assessment</span>
                                </div>
                                <div class="flex flex-col gap-2 text-sm mt-1">
                                    ${formattedParts}
                                </div>
                            </div>
                        </td>
                    `;
                    tbody.appendChild(subRow);
                }
            });

            if (ideas.length === 0) {
                tbody.innerHTML = '<tr><td colspan="7" class="text-center text-xs text-slate-400 py-8">No entry signals in the last 30 days relative to this snapshot.</td></tr>';
            }
        }

        function updateWeekReview(date) {
            const reviewBody = el('weekly-review-body');
            if (!reviewBody) return;
            reviewBody.innerHTML = '';

            const recent = TRADES.filter(t => compareDates(t.Date, date) <= 0).slice().reverse().slice(0, 15);

            recent.forEach(t => {
                let pnlValue = 0;
                let resultHtml = '';
                let rowClass = 'bg-white border-b border-slate-50';

                if (t.Action === 'BUY' || t.Action === 'ADD') {
                    const closeTrade = TRADES.find(ct => ct.Symbol === t.Symbol && compareDates(ct.Date, t.Date) > 0 && compareDates(ct.Date, date) <= 0 && (ct.Action === 'SELL' || ct.Action === 'STOP' || ct.Action === 'CLOSE'));

                    if (closeTrade) {
                        const px = parseFloat(closeTrade.PnL || 0) * getFX(closeTrade.Date, STATE.currency);
                        pnlValue = px;
                        const pnlClass = pnlValue >= 0 ? 'text-emerald-600' : 'text-rose-600';
                        resultHtml = `<span class="font-bold ${pnlClass}">${fmtMoney(pnlValue)}</span>`;
                    } else {
                        // Still open
                        resultHtml = `<span class="text-slate-300 text-xs italic">Open</span>`;
                    }
                } else if (t.Action === 'SELL' || t.Action === 'STOP' || t.Action === 'CLOSE') {
                    // For closing trades, show their realized PnL
                    const closeTrade = t;
                    const px = parseFloat(closeTrade.PnL || 0) * getFX(closeTrade.Date, STATE.currency);
                    pnlValue = px;
                    const pnlClass = pnlValue >= 0 ? 'text-emerald-600' : 'text-rose-600';
                    resultHtml = `<span class="font-bold ${pnlClass}">${fmtMoney(pnlValue)}</span>`;
                }

                // Row background based on PnL
                if (pnlValue > 500) rowClass = 'bg-emerald-50 border-l-4 border-emerald-500';
                else if (pnlValue > 0) rowClass = 'bg-emerald-50/50';
                else if (pnlValue < -500) rowClass = 'bg-rose-50 border-l-4 border-rose-500';
                else if (pnlValue < 0) rowClass = 'bg-rose-50/50';

                const tradeFX = getFX(t.Date, STATE.currency);
                const reasonIcon = t.Reason ? `<span class="tooltip-wrapper"><span class="info-icon">?</span><span class="tooltip-text">${t.Reason.replace(/"/g, '&quot;').replace(/</g, '&lt;').replace(/>/g, '&gt;')}</span></span>` : '';
                const tr = document.createElement('tr');
                tr.className = rowClass;
                tr.innerHTML = `<td class="px-3 py-2 text-slate-500 font-mono text-xs">${fmtDate(t.Date)}</td><td class="px-3 py-2 font-bold text-slate-700">${t.Symbol}${reasonIcon}</td><td class="px-3 py-2 text-xs text-slate-500">Entry</td><td class="px-3 py-2 text-right font-mono text-xs">${(parseFloat(t.Price) * tradeFX).toFixed(2)}</td><td class="px-3 py-2 text-right text-xs">${resultHtml}</td>`;
                reviewBody.appendChild(tr);
            });
        }

        function updateLogs(date, fx) {
            const table = el('journal-table');
            if (!table) return; // Ensure table element exists
            table.innerHTML = '';
            // Robust Filtering: Compare ISO strings
            const currentSnapIso = date.replace(' ', 'T');
            // Core Filter: Trades BEFORE or EQUAL to current selected date
            let filtered = TRADES.filter(t => compareDates(t.Date, date) <= 0).slice().reverse();

            // Fallback: If 0 trades found, but we are looking at a Daily granularity (T00:00:00), 
            // and there are trades ON that day (e.g. T10:00:00), include them to avoid "No trades" confusion.
            if (filtered.length === 0) {
                const dayPrefix = date.split('T')[0];
                const sameDayTrades = TRADES.filter(t => t.Date.startsWith(dayPrefix)).slice().reverse();
                if (sameDayTrades.length > 0) {
                    filtered = sameDayTrades;
                }
            }

            if (filtered.length === 0) {
                table.innerHTML = `<thead><tr><th class="px-4 py-2 text-slate-400 italic text-center" colspan="6">No trades found up to ${date}.</th></tr></thead>`;
                return;
            }

            if (STATE.journalMode === 'grouped') {
                const groups = {};
                filtered.forEach(t => { if (!groups[t.Symbol]) groups[t.Symbol] = []; groups[t.Symbol].push(t); });
                const entries = Object.keys(groups).map(sym => {
                    const trades = groups[sym];
                    const net = trades.reduce((a, b) => {
                        const tFX = getFX(b.Date, STATE.currency);
                        return a + (parseFloat(b.PnL || 0) * tFX);
                    }, 0);
                    return { sym, trades, net };
                });
                entries.sort((a, b) => b.net - a.net);

                entries.forEach(e => {
                    const { sym, trades, net } = e;
                    const color = net >= 0 ? 'text-emerald-600' : 'text-rose-600';
                    const h = document.createElement('tr');
                    h.className = "bg-slate-50 cursor-pointer hover:bg-slate-100 border-b border-white";
                    h.innerHTML = `<td colspan="7" class="px-4 py-2 font-bold text-slate-700 flex justify-between items-center"><span><i class="fa-solid fa-chevron-right text-xs mr-2"></i> ${sym} (${trades.length})</span> <span class="${color}">${fmtMoney(net)}</span></td>`;
                    h.onclick = function () {
                        const next = this.nextElementSibling;
                        if (next) next.classList.toggle('hidden');
                    };
                    table.appendChild(h);
                    const b = document.createElement('tbody');
                    b.className = "hidden bg-white";
                    trades.forEach(t => renderTradeRow(t, b));
                    table.appendChild(b);
                });
            } else {
                table.innerHTML = `<thead class="bg-slate-50 text-slate-500 uppercase text-xs font-bold"><tr>
                    <th class="px-4 py-3 cursor-pointer hover:bg-slate-100 transition-colors" onclick="toggleSort('journal', 'Date')">Date <i class="fa-solid fa-sort ml-1 opacity-30"></i></th>
                    <th class="px-4 py-3 cursor-pointer hover:bg-slate-100 transition-colors" onclick="toggleSort('journal', 'Symbol')">Sym <i class="fa-solid fa-sort ml-1 opacity-30"></i></th>
                    <th class="px-4 py-3 cursor-pointer hover:bg-slate-100 transition-colors" onclick="toggleSort('journal', 'Action')">Action <i class="fa-solid fa-sort ml-1 opacity-30"></i></th>
                    <th class="px-4 py-3 text-right cursor-pointer hover:bg-slate-100 transition-colors" onclick="toggleSort('journal', 'Price')">Price <i class="fa-solid fa-sort ml-1 opacity-30"></i></th>
                    <th class="px-4 py-3 text-right cursor-pointer hover:bg-slate-100 transition-colors" onclick="toggleSort('journal', 'Shares')">Qty <i class="fa-solid fa-sort ml-1 opacity-30"></i></th>
                    <th class="px-4 py-3 text-right cursor-pointer hover:bg-slate-100 transition-colors" onclick="toggleSort('journal', 'PnL')">PnL <i class="fa-solid fa-sort ml-1 opacity-30"></i></th>
                </tr></thead><tbody></tbody>`;
                const tbody = table.querySelector('tbody');

                const s = STATE.sort.journal;
                const sorted = filtered.sort((a, b) => {
                    let vA = a[s.col];
                    let vB = b[s.col];
                    if (s.col === 'Price' || s.col === 'Shares' || s.col === 'PnL') {
                        vA = parseFloat(vA || 0);
                        vB = parseFloat(vB || 0);
                    }
                    if (typeof vA === 'string') return vA.localeCompare(vB) * s.dir;
                    return (vA - vB) * s.dir;
                });

                sorted.forEach(t => renderTradeRow(t, tbody));
            }
        }

        function renderTradeRow(t, container) {
            const tr = document.createElement('tr');
            const fx = getFX(t.Date, STATE.currency);
            const pnl = parseFloat(t.PnL || 0) * fx;
            const pnlClass = pnl > 0 ? 'text-emerald-600' : (pnl < 0 ? 'text-rose-600' : 'text-slate-300');
            const reasonIcon = t.Reason ? `<span class="tooltip-wrapper"><span class="info-icon">?</span><span class="tooltip-text">${t.Reason.replace(/"/g, '&quot;').replace(/</g, '&lt;').replace(/>/g, '&gt;')}</span></span>` : '';
            tr.innerHTML = `<td class="px-4 py-3 text-slate-500 font-mono text-xs group-hover:text-blue-500 transition-colors">${fmtDate(t.Date)}</td>
                <td class="px-4 py-3 font-bold text-slate-700">${t.Symbol}</td>
                <td class="px-4 py-3"><span class="px-2 py-1 rounded text-[10px] uppercase font-bold tracking-wider ${t.Action.includes('BUY') ? 'bg-blue-100 text-blue-700' : (t.Action === 'TRAIL' ? 'bg-amber-100 text-amber-700' : 'bg-slate-100 text-slate-700')}">${t.Action}</span>${reasonIcon}</td>
                <td class="px-4 py-3 text-right font-mono">${(parseFloat(t.Price) * fx).toFixed(2)}</td>
                <td class="px-4 py-3 text-right font-mono text-slate-600">${t.Shares}</td>
                <td class="px-4 py-3 text-right font-bold ${pnlClass}">${pnl ? fmtMoney(pnl) : '-'}</td>`;
            container.appendChild(tr);
        }

        function updateTimeline(date) {
            const container = el('timeline-container');
            if (!container) return;
            container.innerHTML = '';
            const recent = TRADES.filter(t => compareDates(t.Date, date) <= 0).slice().reverse().slice(0, 10);
            recent.forEach(t => {
                const fx = getFX(t.Date, STATE.currency);
                const div = document.createElement('div');
                div.className = "relative pl-6 pb-6 border-l-2 border-slate-100 ml-2";
                div.innerHTML = `<div class="absolute w-3 h-3 bg-white border-2 border-blue-500 rounded-full -left-[7px] top-0"></div><div class="text-xs text-slate-400 font-mono mb-1">${fmtDate(t.Date)}</div><div class="font-bold text-slate-800 text-sm">${t.Action} ${t.Symbol}</div><div class="text-xs text-slate-500">@ ${(parseFloat(t.Price) * fx).toFixed(2)}</div>`;
                container.appendChild(div);
            });
        }

        function updateTopHoldings(snap, fx) {
            const container = el('top-holdings-list');
            if (!container) return;
            container.innerHTML = '';

            if (!snap.positions || snap.positions.length === 0) {
                container.innerHTML = '<div class="text-xs text-slate-400 italic text-center p-2">Positions detailed data not available for this specific date (Optimization).</div>';
                return;
            }

            const sorted = snap.positions.sort((a, b) => b.value - a.value).slice(0, 10);
            sorted.forEach(p => {
                const val = p.value || 0;
                const ac = p.asset_class || p.ac || 'EQ';
                const symb = p.symbol || 'Unknown';

                const w = (snap.equity > 0) ? (val / snap.equity) * 100 : 0;
                const div = document.createElement('div');
                div.className = "flex justify-between items-center text-sm p-2 hover:bg-slate-50 rounded transition-colors border-b border-slate-50";
                div.innerHTML = `<div class="flex items-center gap-3"><span class="font-bold text-slate-700 text-xs w-16">${symb}</span><span class="text-xs text-slate-400">${ac}</span></div><span class="font-mono text-sm font-bold text-slate-700">${w.toFixed(1)}%</span>`;
                container.appendChild(div);
            });
        }

        function updateBestWorstTrades(date, fx) {
            const bestList = el('best-trades-list');
            const worstList = el('worst-trades-list');
            if (!bestList || !worstList) return;

            // Filter trades up to selected date with realized PnL
            const tradesWithPnL = TRADES.filter(t => compareDates(t.Date, date) <= 0 && parseFloat(t.PnL) !== 0);

            // Sort by PnL
            const sorted = tradesWithPnL.slice().sort((a, b) => parseFloat(b.PnL) - parseFloat(a.PnL));

            const best3 = sorted.slice(0, 3);
            const worst3 = sorted.slice(-3).reverse();

            bestList.innerHTML = '';
            best3.forEach(t => {
                const pnl = parseFloat(t.PnL) * getFX(t.Date, STATE.currency);
                const div = document.createElement('div');
                div.className = "flex justify-between items-center p-3 bg-emerald-50 rounded-lg border border-emerald-100";
                div.innerHTML = `<div><span class="font-bold text-slate-800">${t.Symbol}</span><span class="text-xs text-slate-400 ml-2">${fmtDate(t.Date)}</span></div><span class="text-emerald-600 font-bold">${fmtMoney(pnl)}</span>`;
                bestList.appendChild(div);
            });
            if (best3.length === 0) bestList.innerHTML = '<div class="text-slate-400 text-sm italic text-center p-4">No closed trades yet</div>';

            worstList.innerHTML = '';
            worst3.forEach(t => {
                const pnl = parseFloat(t.PnL) * getFX(t.Date, STATE.currency);
                const div = document.createElement('div');
                div.className = "flex justify-between items-center p-3 bg-rose-50 rounded-lg border border-rose-100";
                div.innerHTML = `<div><span class="font-bold text-slate-800">${t.Symbol}</span><span class="text-xs text-slate-400 ml-2">${fmtDate(t.Date)}</span></div><span class="text-rose-600 font-bold">${fmtMoney(pnl)}</span>`;
                worstList.appendChild(div);
            });
            if (worst3.length === 0) worstList.innerHTML = '<div class="text-slate-400 text-sm italic text-center p-4">No closed trades yet</div>';
        }

        function updateCorrelationMatrix(snap) {
            const table = el('corr-matrix');
            const warning = el('corr-warning');
            if (!table) return;

            const symbols = snap.positions.map(p => p.symbol).slice(0, 10); // Limit to top 10
            if (symbols.length < 2) {
                table.innerHTML = '<tr><td class="text-slate-400 text-center p-4">Need at least 2 positions for correlation</td></tr>';
                return;
            }

            // Generate mock correlations (in real app, this would use actual price data)
            // Using symbol hash to generate consistent "random" correlations
            const corrs = {};
            const hashCode = (s) => s.split('').reduce((a, b) => (((a << 5) - a) + b.charCodeAt(0)) | 0, 0);

            let hasHighCorr = false;
            symbols.forEach(s1 => {
                corrs[s1] = {};
                symbols.forEach(s2 => {
                    if (s1 === s2) {
                        corrs[s1][s2] = 1.0;
                    } else {
                        // Generate pseudo-random correlation based on symbol pair
                        const seed = Math.abs(hashCode(s1 + s2)) / 2147483647;
                        const corr = (seed * 0.8) + 0.1; // Range 0.1 to 0.9
                        corrs[s1][s2] = corr;
                        if (corr > 0.8) hasHighCorr = true;
                    }
                });
            });

            // Render Matrix
            let html = '<thead><tr><th class="p-2 text-slate-400"></th>';
            symbols.forEach(s => html += '<th class="p-2 text-slate-600 font-bold text-xs w-16">' + s.substring(0, 6) + '</th>');
            html += '</tr></thead><tbody>';

            symbols.forEach(s1 => {
                html += '<tr><td class="p-2 text-slate-600 font-bold text-xs">' + s1.substring(0, 6) + '</td>';
                symbols.forEach(s2 => {
                    const c = corrs[s1][s2];
                    let cellClass = 'bg-white text-slate-300';
                    let display = '';

                    if (s1 === s2) {
                        cellClass = 'bg-slate-100 text-slate-400';
                        display = '1.0';
                    } else if (Math.abs(c) >= 0.8) {
                        cellClass = 'bg-red-100 text-red-700 font-bold';
                        display = c.toFixed(2);
                    } else if (Math.abs(c) >= 0.6) {
                        cellClass = 'bg-orange-100 text-orange-700';
                        display = c.toFixed(2);
                    } else if (Math.abs(c) >= 0.5) {
                        cellClass = 'bg-slate-100 text-slate-600';
                        display = c.toFixed(2);
                    }

                    html += '<td class="p-2 text-center text-xs ' + cellClass + '">' + display + '</td>';
                });
                html += '</tr>';
            });
            html += '</tbody>';
            table.innerHTML = html;

            // Show warning if high correlation detected
            if (hasHighCorr) {
                warning.classList.remove('hidden');
            } else {
                warning.classList.add('hidden');
            }
        }

        function setJournalMode(m) {
            STATE.journalMode = m;

            const listView = el('journal-list-view');
            const calView = el('journal-calendar-view');
            const accView = el('journal-accounting-view');

            if (m === 'calendar') {
                if (listView) listView.classList.add('hidden');
                if (accView) accView.classList.add('hidden');
                if (calView) calView.classList.remove('hidden');
                renderCalendar();
            } else if (m === 'accounting') {
                if (listView) listView.classList.add('hidden');
                if (calView) calView.classList.add('hidden');
                if (accView) accView.classList.remove('hidden');
                renderAccountingView();
            } else {
                if (listView) listView.classList.remove('hidden');
                if (calView) calView.classList.add('hidden');
                if (accView) accView.classList.add('hidden');
                if (DATA.history && DATA.history[STATE.idx]) {
                    updateLogs(DATA.history[STATE.idx].date, getFX(DATA.history[STATE.idx].date, STATE.currency));
                }
            }

            const btnFlat = el('btn-flat');
            const btnGrp = el('btn-grp');
            const btnCal = el('btn-cal');
            const btnAcc = el('btn-acc');
            const activeClass = 'px-3 py-1 text-xs rounded font-bold transition bg-slate-800 text-white shadow-sm';
            const inactiveClass = 'px-3 py-1 text-xs rounded font-bold transition bg-white text-slate-600 hover:bg-slate-50 border border-slate-200';

            if (btnFlat) btnFlat.className = m === 'flat' ? activeClass : inactiveClass;
            if (btnGrp) btnGrp.className = m === 'grouped' ? activeClass : inactiveClass;
            if (btnCal) btnCal.className = m === 'calendar' ? activeClass : inactiveClass;
            if (btnAcc) btnAcc.className = m === 'accounting' ? activeClass : inactiveClass;
        }

        function renderAccountingView() {
            const snap = DATA.history[STATE.idx];
            if (!snap) return;

            const fx = getFX(snap.date, STATE.currency);
            const dateStr = fmtDate(snap.date);

            if (el('acc-date')) el('acc-date').innerText = dateStr;

            const snapUnrealized = snap.unrealized !== undefined ? snap.unrealized : snap.unrealized_pnl;
            const snapRealized = snap.realized !== undefined ? snap.realized : snap.realized_pnl;

            // Total Realized PnL calculation up to this date
            // Prefer snapRealized if available (from auditor), otherwise sum trades
            let realizedSum = snapRealized || 0;
            if ((realizedSum === 0 || realizedSum === undefined) && DATA.trades) {
                realizedSum = DATA.trades
                    .filter(t => t.Date <= snap.date && (t.Action.includes('SELL') || t.Action.includes('STOP')))
                    .reduce((sum, t) => sum + (parseFloat(t.PnL) || 0), 0);
            }

            // Unrealized calculation from snapshot positions
            let unrealizedSum = (snapUnrealized !== undefined) ? snapUnrealized : 0;
            if ((unrealizedSum === 0 || unrealizedSum === undefined) && snap.positions) {
                snap.positions.forEach(p => {
                    const pnl = p.unrealized_pnl !== undefined ? p.unrealized_pnl : (p.avg_cost ? (p.price - p.avg_cost) * p.shares : 0);
                    unrealizedSum += pnl;
                });
            }

            // Main Totals
            if (el('acc-total')) el('acc-total').innerText = fmtMoney(snap.equity * fx);
            if (el('acc-cash')) el('acc-cash').innerText = fmtMoney(snap.cash * fx);
            if (el('acc-realized')) el('acc-realized').innerText = fmtMoney(realizedSum * fx);
            if (el('acc-unrealized')) el('acc-unrealized').innerText = fmtMoney(unrealizedSum * fx);

            // Committed Positions Table
            const posBody = el('acc-positions-body');
            if (posBody) {
                posBody.innerHTML = '';
                if (!snap.positions || snap.positions.length === 0) {
                    posBody.innerHTML = '<tr><td colspan="8" class="px-4 py-8 text-center text-slate-400 italic">No committed positions on this date</td></tr>';
                } else {
                    // Sorting Logic
                    let sortedPos = [...snap.positions];
                    if (STATE.sort && STATE.sort.acc_pos) {
                        const s = STATE.sort.acc_pos;
                        sortedPos.sort((a, b) => {
                            let va = a[s.col];
                            let vb = b[s.col];
                            // Special handling for Entry Date defaulting
                            if (s.col === 'entry_date') va = a.entry_date || '';
                            if (s.col === 'entry_date') vb = b.entry_date || '';

                            if (va === undefined) va = 0;
                            if (vb === undefined) vb = 0;

                            if (typeof va === 'string') return va.localeCompare(vb) * s.dir;
                            return (va - vb) * s.dir;
                        });
                    } else {
                        // Default sort by value descending
                        sortedPos.sort((a, b) => (b.value || 0) - (a.value || 0));
                    }

                    sortedPos.forEach(p => {
                        const tr = document.createElement('tr');
                        tr.className = "hover:bg-slate-50 transition-colors border-b border-slate-100 last:border-0";

                        // Try to find the entry date for this symbol
                        // Priority: 1. p.entry_date, 2. Manual search in trades
                        let entryDate = p.entry_date ? fmtDate(p.entry_date) : '-';
                        if (entryDate === '-' && DATA.trades) {
                            const entryTrade = DATA.trades
                                .filter(t => t.Symbol === p.symbol && t.Date <= snap.date && t.Action.includes('BUY'))
                                .sort((a, b) => new Date(a.Date) - new Date(b.Date))[0];
                            if (entryTrade) entryDate = fmtDate(entryTrade.Date);
                        }

                        const pnl = p.unrealized_pnl !== undefined ? p.unrealized_pnl : (p.avg_cost ? (p.price - p.avg_cost) * p.shares : 0);
                        const weight = snap.equity > 0 ? ((p.value || (p.shares * p.price)) / snap.equity * 100).toFixed(1) : '0.0';
                        const nativeCur = p.native_currency || getNativeCurrency(p.symbol);

                        // Use native values if available for local pricing displays
                        const displayCost = p.native_avg_cost !== undefined ? p.native_avg_cost : p.avg_cost;
                        const displayPrice = p.native_price !== undefined ? p.native_price : p.price;

                        tr.innerHTML = `
                            <td class="px-4 py-3">
                                <div class="font-bold text-slate-800">${p.symbol}</div>
                                <div class="text-[10px] text-slate-400 uppercase font-medium">${p.sector || 'General'}</div>
                            </td>
                            <td class="px-4 py-3 text-right font-mono font-bold text-slate-600">${p.shares.toLocaleString()}</td>
                            <td class="px-4 py-3 text-right font-mono text-slate-500">${entryDate}</td>
                            <td class="px-4 py-3 text-right font-mono text-slate-500">${fmtMoney(displayCost || 0, nativeCur)}</td>
                            <td class="px-4 py-3 text-right font-mono text-slate-500">${fmtMoney(displayPrice || 0, nativeCur)}</td>
                            <td class="px-4 py-3 text-right font-mono font-bold text-slate-800">${fmtMoney((p.value || p.shares * p.price) * fx)}</td>
                            <td class="px-4 py-3 text-right font-mono ${pnl >= 0 ? 'text-emerald-600' : 'text-rose-600'}">
                                ${pnl >= 0 ? '+' : ''}${fmtMoney(pnl * fx)}
                            </td>
                            <td class="px-4 py-3 text-right"><span class="bg-slate-100 px-2 py-0.5 rounded text-[10px] font-bold text-slate-600">${weight}%</span></td>
                        `;
                        posBody.appendChild(tr);
                    });
                }
            }

            // Pending Orders Table
            const pendBody = el('acc-pending-body');
            if (pendBody) {
                pendBody.innerHTML = '';
                const orders = snap.pending_orders || [];

                if (orders.length === 0) {
                    pendBody.innerHTML = '<tr><td colspan="6" class="px-4 py-8 text-center text-slate-400 italic">No pending orders detected for this snapshot</td></tr>';
                } else {
                    orders.forEach(o => {
                        const tr = document.createElement('tr');
                        tr.className = "hover:bg-slate-50 transition-colors border-b border-slate-100 last:border-0";
                        const actionClass = (o.action || '').includes('BUY') ? 'bg-blue-100 text-blue-700' : 'bg-slate-100 text-slate-600';
                        const nativeCur = o.native_currency || getNativeCurrency(o.symbol);

                        // TWAP Label
                        let typeLabel = o.type || 'LIMIT';
                        if (o.is_split_order) {
                            typeLabel += ` (Split ${o.split_index + 1}/${o.split_total_parts})`;
                        }

                        // For pending orders, price might be limit, stop, or simply price
                        const oPrice = o.limit || o.stop || o.price || 0;

                        tr.innerHTML = `
                            <td class="px-4 py-3 font-bold text-slate-800">${o.symbol}</td>
                            <td class="px-4 py-3 text-xs font-mono text-slate-400">${fmtDate(o.date || snap.date)}</td>
                            <td class="px-4 py-3"><span class="text-[10px] px-2 py-1 rounded font-bold uppercase tracking-wider ${actionClass}">${typeLabel} ${o.action || 'BUY'}</span></td>
                            <td class="px-4 py-3 text-right font-mono font-bold text-slate-600">${(o.qty || o.shares || 0).toLocaleString()}</td>
                            <td class="px-4 py-3 text-right font-mono font-bold text-slate-800">${fmtMoney(oPrice, nativeCur)}</td>
                            <td class="px-4 py-3"><span class="text-[10px] text-amber-600 font-black uppercase bg-amber-50 px-2 py-1 rounded border border-amber-100">${o.status || 'PENDING'}</span></td>
                        `;
                        pendBody.appendChild(tr);
                    });
                }
            }
        }

        function changeCalYear(delta) {
            if (!STATE.calYear || !STATE.calMonth) {
                const currentDate = DATA.history[STATE.idx]?.date || new Date().toISOString().split('T')[0];
                const [y, m] = currentDate.split('-').map(Number);
                STATE.calYear = y;
                STATE.calMonth = m;
            }
            STATE.calYear += delta;
            STATE.calMonth = 1; // Always reset to January
            renderCalendar();
        }

        function renderCalendar() {
            const grid = el('calendar-grid');
            const monthLabel = el('cal-month-label');
            if (!grid) return;
            grid.innerHTML = '';

            const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];

            const currentDate = DATA.history[STATE.idx]?.date || new Date().toISOString().split('T')[0];
            const [defaultYear, defaultMonth] = currentDate.split('-').map(Number);

            // Use navigated month or default to Time Machine date
            let year = STATE.calYear || defaultYear;
            let month = STATE.calMonth || defaultMonth;
            if (!STATE.calYear) { STATE.calYear = year; STATE.calMonth = month; }

            // Update month label (Year Only)
            if (monthLabel) monthLabel.innerText = `${year}`;

            // Render 3 Months side by side: Previous, Current, Next
            // We'll create a flex container for them
            grid.className = "flex overflow-x-auto gap-4 pb-2"; // Override grid-cols-7

            // Helper to render one month
            const renderMonth = (y, m) => {
                const mDiv = document.createElement('div');
                mDiv.className = "min-w-[280px] bg-white rounded border border-slate-100 p-2";
                mDiv.innerHTML = `<h5 class="text-center font-bold text-slate-400 mb-2">${monthNames[m - 1]} ${y}</h5>`;

                const dGrid = document.createElement('div');
                dGrid.className = "grid grid-cols-7 gap-1";

                // Headers
                ['M', 'T', 'W', 'T', 'F', 'S', 'S'].forEach(d => {
                    dGrid.innerHTML += `<div class="text-center text-[10px] font-bold text-slate-300">${d}</div>`;
                });

                const firstDay = new Date(y, m - 1, 1);
                const daysInMonth = new Date(y, m, 0).getDate();
                let startOffset = (firstDay.getDay() + 6) % 7;

                for (let i = 0; i < startOffset; i++) dGrid.innerHTML += '<div></div>';

                for (let day = 1; day <= daysInMonth; day++) {
                    const dateStr = `${y}-${String(m).padStart(2, '0')}-${String(day).padStart(2, '0')}`;
                    const dayTrades = TRADES.filter(t => getDatePart(t.Date) === dateStr);
                    const hasTrades = dayTrades.length > 0;

                    let regimeClass = 'bg-slate-50 text-slate-400';
                    let dotColor = '';
                    if (hasTrades) {
                        const netPnL = dayTrades.reduce((a, t) => a + parseFloat(t.PnL || 0), 0);
                        if (netPnL > 0) { regimeClass = 'bg-emerald-50 text-emerald-700 font-bold border border-emerald-100'; dotColor = 'bg-emerald-500'; }
                        else if (netPnL < 0) { regimeClass = 'bg-rose-50 text-rose-700 font-bold border border-rose-100'; dotColor = 'bg-rose-500'; }
                        else { regimeClass = 'bg-yellow-50 text-yellow-700 font-bold border border-yellow-100'; dotColor = 'bg-yellow-500'; }
                    }

                    const isSelected = dateStr === currentDate;
                    const selectedClass = isSelected ? 'ring-2 ring-blue-500 z-10' : '';

                    const cell = document.createElement('div');
                    cell.className = `p-1 text-center text-xs rounded cursor-pointer hover:bg-white hover:shadow transition relative ${regimeClass} ${selectedClass}`;
                    cell.innerText = day;
                    if (hasTrades) {
                        const dot = document.createElement('div');
                        dot.className = `absolute bottom-0.5 left-1/2 -translate-x-1/2 w-1 h-1 rounded-full ${dotColor}`;
                        cell.appendChild(dot);
                    }

                    // On click: Select Date AND Update Time Machine
                    cell.onclick = () => {
                        showDayDetail(dateStr);
                        // Find index in history for this date
                        const foundIdx = DATA.history.findIndex(h => h.date >= dateStr);
                        // Approximate: if exact date exists use it, else closests forward
                        if (foundIdx !== -1) {
                            // Update slider and state
                            updateTimeMachine(foundIdx);
                            const slider = el('timeSlider');
                            if (slider) slider.value = foundIdx;
                        }
                    };
                    dGrid.appendChild(cell);
                }
                mDiv.appendChild(dGrid);
                return mDiv;
            };

            // Render 6 Months side by side: centered on current month? Or previous months?
            // User asked "affichÃ© 6 mois" - usually implies recent history + current + future? 
            // Let's do: Current month and 5 previous months? Or 3 prev, current, 2 next?
            // Interpretation: Calendar is usually for reviewing PAST trades. So 5 previous + Current seems best.
            // Render 12 Months: 4 columns x 3 rows
            grid.className = "grid grid-cols-2 md:grid-cols-4 gap-4 pb-2";

            const renderRelativeMonth = (offset) => {
                let targetM = month + offset;
                let targetY = year;
                while (targetM < 1) { targetM += 12; targetY--; }
                while (targetM > 12) { targetM -= 12; targetY++; }
                return renderMonth(targetY, targetM);
            };

            // Display 1 Full Year (12 months), ending with the current selected month
            for (let i = -11; i <= 0; i++) {
                grid.appendChild(renderRelativeMonth(i));
            }

            // Automatically show detail for the currently selected state date
            const datePart = currentDate.split('T')[0].split(' ')[0];
            showDayDetail(datePart);
        }

        function showDayDetail(dateStr) {
            const detail = el('calendar-day-detail');
            const dateTitle = el('cal-detail-date');
            const tradesDiv = el('cal-detail-trades');

            if (!detail) return;
            detail.classList.remove('hidden');
            // DATE TITLE IS HANDLED BELOW
            // dateTitle.innerText = dateStr; 

            const dayTrades = TRADES.filter(t => getDatePart(t.Date) === dateStr);
            tradesDiv.innerHTML = '';

            if (dayTrades.length === 0) {
                tradesDiv.innerHTML = '<div class="text-slate-400 italic text-sm">No trades on this day</div>';
            } else {
                let totalDailyPnL = 0;
                dayTrades.forEach(t => {
                    totalDailyPnL += parseFloat(t.PnL || 0) * getFX(t.Date, STATE.currency);
                });

                const dailyPnlClass = totalDailyPnL >= 0 ? 'text-emerald-700 bg-emerald-50 border-emerald-200' : 'text-rose-700 bg-rose-50 border-rose-200';

                // Header UX: Calendar Icon + Date + PnL Badge
                dateTitle.className = "flex justify-between items-center mb-4";
                dateTitle.innerHTML = `
                    <div class="flex items-center gap-2 text-lg text-slate-800 font-bold">
                        <i class="fa-regular fa-calendar text-slate-400"></i>
                        <span>${dateStr}</span>
                    </div>
                    <div class="px-3 py-1 rounded-lg border font-mono font-bold ${dailyPnlClass}">
                        ${totalDailyPnL >= 0 ? '+' : ''}${fmtMoney(totalDailyPnL)}
                    </div>
                `;

                // Sort Details Logic
                if (STATE.sort && STATE.sort.detail) {
                    const col = STATE.sort.detail.col;
                    const dir = STATE.sort.detail.dir;
                    dayTrades.sort((a, b) => {
                        let va, vb;
                        if (col === 'Symbol') { va = a.Symbol; vb = b.Symbol; }
                        else if (col === 'Action') { va = a.Action; vb = b.Action; }
                        else if (col === 'Amount') { va = parseFloat(a.Price) * a.Shares; vb = parseFloat(b.Price) * b.Shares; }
                        else if (col === 'Impact') { va = parseFloat(a.PnL || 0); vb = parseFloat(b.PnL || 0); }

                        if (typeof va === 'string') return va.localeCompare(vb) * dir;
                        return (va - vb) * dir;
                    });
                }

                const shortPeriods = ['24h', '48h', '1w', '2w'];
                const isIntraday = shortPeriods.includes(CURRENT_PERIOD);
                const timeHeader = isIntraday ? '<th class="px-4 py-3 text-slate-500 font-mono text-[10px]">Time</th>' : '';

                // Table for Details
                const table = document.createElement('table');
                table.className = "w-full text-sm text-left table-auto";
                table.innerHTML = `
                    <thead class="bg-slate-50 text-xs uppercase font-bold text-slate-500">
                        <tr>
                            ${timeHeader}
                            <th class="px-4 py-3 cursor-pointer hover:bg-slate-100 transition-colors" onclick="sortDayDetail('${dateStr}', 'Symbol')">Symbol <i class="fa-solid fa-sort ml-1 opacity-30"></i></th>
                            <th class="px-4 py-3 cursor-pointer hover:bg-slate-100 transition-colors" onclick="sortDayDetail('${dateStr}', 'Action')">Action <i class="fa-solid fa-sort ml-1 opacity-30"></i></th>
                            <th class="px-4 py-3 text-right">Qty</th>
                            <th class="px-4 py-3 text-right">Price</th>
                            <th class="px-4 py-3 text-right cursor-pointer hover:bg-slate-100 transition-colors" onclick="sortDayDetail('${dateStr}', 'Amount')">Total <i class="fa-solid fa-sort ml-1 opacity-30"></i></th>
                            <th class="px-4 py-3 text-right cursor-pointer hover:bg-slate-100 transition-colors" onclick="sortDayDetail('${dateStr}', 'Impact')">Impt <i class="fa-solid fa-sort ml-1 opacity-30"></i></th>
                        </tr>
                    </thead>
                    <tbody class="divide-y divide-slate-100 text-slate-700"></tbody>
                `;
                const tbody = table.querySelector('tbody');

                dayTrades.forEach(t => {
                    const fx = getFX(t.Date, STATE.currency);
                    const nativeCur = getNativeCurrency(t.Symbol);

                    const pnl = parseFloat(t.PnL || 0) * fx;
                    const nativePrice = parseFloat(t.Price);
                    const nativeAmount = nativePrice * parseFloat(t.Shares);

                    const pnlClass = pnl > 0 ? 'text-emerald-600' : (pnl < 0 ? 'text-rose-600' : 'text-slate-400');
                    const actionClass = t.Action.includes('BUY') ? 'bg-blue-50 text-blue-700 border border-blue-100' : 'bg-slate-50 text-slate-600 border border-slate-100';
                    const flag = getCountryFlag(t.Symbol);

                    const timeCell = isIntraday ? `<td class="px-4 py-1.5 font-mono text-xs text-slate-400">${t.Date.includes('T') ? t.Date.split('T')[1].substring(0, 5) : '-'}</td>` : '';

                    const tr = document.createElement('tr');
                    tr.className = "hover:bg-slate-50 transition-colors";
                    tr.innerHTML = `
                        ${timeCell}
                        <td class="px-4 py-1.5 text-xs text-slate-700 font-bold"><span class="mr-2 text-base">${flag}</span>${t.Symbol}</td>
                        <td class="px-4 py-1.5"><span class="text-[10px] px-1.5 py-0.5 rounded uppercase ${actionClass}">${t.Action}</span></td>
                        <td class="px-4 py-1.5 text-right font-mono text-xs text-slate-500">${t.Shares}</td>
                        <td class="px-4 py-1.5 text-right font-mono text-xs text-slate-500">${fmtMoney(nativePrice, nativeCur)}</td>
                        <td class="px-4 py-1.5 text-right font-mono text-xs text-slate-700 font-bold">${fmtMoney(nativeAmount, nativeCur)}</td>
                        <td class="px-4 py-1.5 text-right font-mono text-xs ${pnlClass}">${pnl ? fmtMoney(pnl) : '-'}</td>
                    `;
                    tbody.appendChild(tr);
                });
                tradesDiv.appendChild(table);
            }
        }

        function sortDayDetail(dateStr, col) {
            if (!STATE.sort.detail) STATE.sort.detail = { col: '', dir: 1 };
            if (STATE.sort.detail.col === col) STATE.sort.detail.dir *= -1;
            else { STATE.sort.detail.col = col; STATE.sort.detail.dir = 1; }
            showDayDetail(dateStr);
        }

        // --- UI Handlers ---
        window.toggleStatsPopover = function (e) {
            e.stopPropagation(); // prevent click from bubbling to document
            const pop = document.getElementById('popover-stats');
            const btn = document.getElementById('btn-stats-toggle');
            if (!pop || !btn) return;

            if (pop.classList.contains('hidden')) {
                // Open
                pop.classList.remove('hidden');
                btn.classList.add('bg-indigo-100', 'ring-2', 'ring-indigo-200');
            } else {
                // Close
                pop.classList.add('hidden');
                btn.classList.remove('bg-indigo-100', 'ring-2', 'ring-indigo-200');
            }
        };

        // Close Popover on click outside
        document.addEventListener('click', function (e) {
            const pop = document.getElementById('popover-stats');
            const btn = document.getElementById('btn-stats-toggle');
            if (pop && !pop.classList.contains('hidden')) {
                // If click is NOT inside popover AND NOT inside the button
                if (!pop.contains(e.target) && !btn.contains(e.target)) {
                    pop.classList.add('hidden');
                    if (btn) btn.classList.remove('bg-indigo-100', 'ring-2', 'ring-indigo-200');
                }
            }
        });

        // ===================================
        // DRIFT DETECTION & QUALITY ANALYSIS
        // ===================================

        let driftChartsInstances = {
            returns: null,
            prediction: null,
            volatility: null
        };

        // Calculate KL Divergence between two distributions
        function calculateKLDivergence(p, q) {
            let kl = 0;
            const epsilon = 1e-10; // Prevent log(0)
            for (let i = 0; i < p.length; i++) {
                if (p[i] > epsilon) {
                    kl += p[i] * Math.log((p[i] + epsilon) / (q[i] + epsilon));
                }
            }
            return kl;
        }

        // Calculate PSI (Population Stability Index)
        function calculatePSI(expected, actual) {
            let psi = 0;
            const epsilon = 1e-10;
            for (let i = 0; i < expected.length; i++) {
                const exp = expected[i] + epsilon;
                const act = actual[i] + epsilon;
                psi += (act - exp) * Math.log(act / exp);
            }
            return psi;
        }

        // Create histogram bins for distribution
        function createHistogram(values, bins = 20) {
            if (!values || values.length === 0) return { counts: [], bins: [] };

            const min = Math.min(...values);
            const max = Math.max(...values);
            const binSize = (max - min) / bins;

            const counts = new Array(bins).fill(0);
            const binEdges = [];

            for (let i = 0; i <= bins; i++) {
                binEdges.push(min + i * binSize);
            }

            values.forEach(v => {
                let binIdx = Math.floor((v - min) / binSize);
                if (binIdx === bins) binIdx = bins - 1; // Last value goes in last bin
                if (binIdx >= 0 && binIdx < bins) counts[binIdx]++;
            });

            // Normalize to probability
            const total = values.length;
            const probs = counts.map(c => c / total);

            return { counts: probs, bins: binEdges };
        }

        // Store gaps data globally
        window.GAPS_DATA = [];

        // Detect price gaps by symbol with SL impact analysis
        function detectPriceGapsDetailed(history, trades, threshold = 0.05) {
            const gaps = [];

            if (!history || history.length < 2) return gaps;

            // Build a map of positions with stop losses at each date
            const positionsByDate = {};
            history.forEach(snap => {
                positionsByDate[snap.date] = snap.positions || [];
            });

            // Build map of SL hit trades with their actual PnL
            const slHitTrades = new Map();
            if (trades) {
                trades.forEach(t => {
                    const action = (t.Action || '').toUpperCase();
                    const reason = (t.Reason || '').toUpperCase();
                    if (action.includes('STOP') || reason.includes('STOP LOSS')) {
                        const key = `${t.Symbol}_${t.Date}`;
                        slHitTrades.set(key, {
                            pnl: t.PnL || 0,
                            price: t.Price || 0,
                            shares: t.Shares || 0
                        });
                    }
                });
            }

            // Track gaps already detected to avoid duplicates
            const seenGaps = new Set();

            // Detect gaps by analyzing each symbol's price movement
            for (let i = 1; i < history.length; i++) {
                const prevSnap = history[i - 1];
                const currSnap = history[i];

                const prevPositions = prevSnap.positions || [];
                const currPositions = currSnap.positions || [];

                // Build map of current positions by symbol
                const currPosMap = {};
                currPositions.forEach(p => {
                    currPosMap[p.symbol] = p;
                });

                // Check each previous position for gaps
                prevPositions.forEach(prevPos => {
                    const symbol = prevPos.symbol;
                    const prevPrice = prevPos.price || prevPos.native_price || 0;
                    const currPos = currPosMap[symbol];

                    if (prevPrice > 0) {
                        let currPrice = 0;
                        let gapPct = 0;
                        let positionClosed = false;

                        // Determine current price
                        if (currPos) {
                            currPrice = currPos.price || currPos.native_price || 0;
                            gapPct = currPrice > 0 ? Math.abs((currPrice - prevPrice) / prevPrice) : 0;
                        } else {
                            // Position closed - check if it was due to SL hit
                            const tradeKey = `${symbol}_${currSnap.date}`;
                            const slTrade = slHitTrades.get(tradeKey);
                            if (slTrade) {
                                currPrice = slTrade.price;
                                gapPct = currPrice > 0 ? Math.abs((currPrice - prevPrice) / prevPrice) : 0;
                                positionClosed = true;
                            }
                        }

                        // Only process if gap is significant
                        if (gapPct > threshold && currPrice > 0) {
                            // Create unique key to avoid duplicates
                            const gapKey = `${symbol}_${currSnap.date}`;
                            if (seenGaps.has(gapKey)) return; // Skip duplicate
                            seenGaps.add(gapKey);

                            const tradeKey = `${symbol}_${currSnap.date}`;
                            const slTrade = slHitTrades.get(tradeKey);
                            let slHit = false;
                            let impact = 0;

                            // If we have an actual SL trade, use its real PnL
                            if (slTrade) {
                                slHit = true;
                                impact = slTrade.pnl; // This is the ACTUAL realized loss in EUR
                            }

                            gaps.push({
                                date: currSnap.date,
                                symbol: symbol,
                                gapPct: gapPct * (currPrice > prevPrice ? 1 : -1), // Keep sign
                                priceBefore: prevPrice,
                                priceAfter: currPrice,
                                slHit: slHit,
                                stopLoss: prevPos.stop_loss || (currPos ? currPos.stop_loss : null),
                                impact: impact, // Only non-zero if actual SL hit with real PnL
                                shares: prevPos.shares,
                                positionClosed: positionClosed
                            });
                        }
                    }
                });
            }

            console.log(`detectPriceGapsDetailed: Found ${gaps.length} gaps`);
            return gaps;
        }

        // Detect missing data points (large date gaps)
        function detectMissingData(history) {
            const missing = [];

            for (let i = 1; i < history.length; i++) {
                const prevDate = new Date(history[i - 1].date);
                const currDate = new Date(history[i].date);
                const daysDiff = (currDate - prevDate) / (1000 * 60 * 60 * 24);

                // If more than 5 days gap (accounting for weekends)
                if (daysDiff > 5) {
                    missing.push({
                        from: history[i - 1].date,
                        to: history[i].date,
                        days: Math.floor(daysDiff)
                    });
                }
            }

            return missing;
        }

        // Calculate rolling volatility
        function calculateRollingVolatility(history, window = 20) {
            const vols = [];

            for (let i = window; i < history.length; i++) {
                const slice = history.slice(i - window, i);
                const returns = [];

                for (let j = 1; j < slice.length; j++) {
                    const ret = (slice[j].equity - slice[j - 1].equity) / slice[j - 1].equity;
                    returns.push(ret);
                }

                // Calculate std dev
                const mean = returns.reduce((a, b) => a + b, 0) / returns.length;
                const variance = returns.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / returns.length;
                const vol = Math.sqrt(variance) * Math.sqrt(252); // Annualized

                vols.push({ date: slice[slice.length - 1].date, vol: vol });
            }

            return vols;
        }

        // Analyze prediction quality (win rate evolution)
        function analyzePredictionQuality(trades) {
            if (!trades || trades.length === 0) {
                console.warn('analyzePredictionQuality: No trades provided');
                return { accuracy: 0, precision: 0, f1: 0, timeline: [], total: 0 };
            }

            console.log(`analyzePredictionQuality: Processing ${trades.length} trades`);

            // Filter sell trades (those with actual PnL)
            const sellTrades = trades.filter(t => {
                const action = (t.Action || '').toUpperCase();
                return action.includes('SELL') || action.includes('STOP');
            });

            console.log(`analyzePredictionQuality: Found ${sellTrades.length} sell trades`);

            if (sellTrades.length === 0) {
                return { accuracy: 0, precision: 0, f1: 0, timeline: [], total: 0 };
            }

            // Sort by date
            sellTrades.sort((a, b) => new Date(a.Date) - new Date(b.Date));

            // Calculate metrics over time windows
            const windowSize = Math.max(5, Math.floor(sellTrades.length / 10));
            const metrics = [];

            for (let i = windowSize; i <= sellTrades.length; i += Math.max(1, Math.floor(windowSize / 3))) {
                const window = sellTrades.slice(Math.max(0, i - windowSize), i);
                const wins = window.filter(t => (t.PnL || 0) > 0).length;
                const total = window.length;

                if (total > 0) {
                    metrics.push({
                        date: window[window.length - 1].Date,
                        accuracy: wins / total
                    });
                }
            }

            console.log(`analyzePredictionQuality: Generated ${metrics.length} timeline points`);

            // Overall metrics
            const totalWins = sellTrades.filter(t => (t.PnL || 0) > 0).length;
            const totalLosses = sellTrades.filter(t => (t.PnL || 0) <= 0).length;
            const totalTrades = sellTrades.length;

            const accuracy = totalWins / totalTrades;
            const precision = totalWins / Math.max(1, totalWins + totalLosses);
            const recall = accuracy;
            const f1 = (precision + recall > 0) ? 2 * (precision * recall) / (precision + recall) : 0;

            console.log(`analyzePredictionQuality: Accuracy=${(accuracy * 100).toFixed(1)}%, Wins=${totalWins}, Losses=${totalLosses}`);

            return {
                accuracy,
                precision,
                f1,
                timeline: metrics,
                total: totalTrades,
                wins: totalWins,
                losses: totalLosses
            };
        }

        // Main function to update Drift & Quality tab
        function updateDriftAnalysis() {
            const history = DATA.history || [];
            const trades = DATA.trades || TRADES || [];

            if (!history || history.length < 2) {
                console.warn("Insufficient history for drift analysis");
                return;
            }

            const currentIdx = STATE.idx || (history.length > 0 ? history.length - 1 : 0);
            const filteredHistory = history.slice(0, currentIdx + 1);

            // Get FX rate for currency conversion (use latest date in view)
            const latestDate = history[history.length - 1]?.date || new Date().toISOString();
            const driftFx = (typeof getFX === 'function') ? getFX(latestDate, STATE.currency) : 1.0;
            window.DRIFT_FX = driftFx; // Store globally for renderGapsTable()

            // Split into baseline (first 60%) and recent (last 40%)
            const splitPoint = Math.floor(filteredHistory.length * 0.6);
            const baseline = filteredHistory.slice(0, splitPoint);
            const recent = filteredHistory.slice(splitPoint);

            // Calculate returns for both periods
            const baselineReturns = [];
            const recentReturns = [];

            for (let i = 1; i < baseline.length; i++) {
                const ret = (baseline[i].equity - baseline[i - 1].equity) / baseline[i - 1].equity;
                baselineReturns.push(ret);
            }

            for (let i = 1; i < recent.length; i++) {
                const ret = (recent[i].equity - recent[i - 1].equity) / recent[i - 1].equity;
                recentReturns.push(ret);
            }

            // Create distributions
            const baselineDist = createHistogram(baselineReturns, 20);
            const recentDist = createHistogram(recentReturns, 20);

            // Calculate drift metrics
            const klDivergence = calculateKLDivergence(recentDist.counts, baselineDist.counts);
            const psiScore = calculatePSI(baselineDist.counts, recentDist.counts);

            // Detect issues with detailed gap analysis
            const gaps = detectPriceGapsDetailed(filteredHistory, trades, 0.05);
            window.GAPS_DATA = gaps; // Store globally for filtering/sorting

            const missing = detectMissingData(filteredHistory);
            const otherIssues = detectOtherIssues(filteredHistory, trades);
            const anomalies = DATA.anomalies || [];

            // Calculate cumulative financial impact
            // Count all negative impacts (actual losses) from all gaps
            const totalGapLoss = gaps.reduce((sum, g) => sum + (g.impact || 0), 0);

            // Count only SL hits and their losses
            const slHitByGaps = gaps.filter(g => g.slHit).length;
            const slHitLoss = gaps.filter(g => g.slHit).reduce((sum, g) => sum + (g.impact || 0), 0);

            const currentEquity = filteredHistory[filteredHistory.length - 1].equity;
            const totalGapLossPct = currentEquity > 0 ? (Math.abs(totalGapLoss) / currentEquity) * 100 : 0;

            // Volatility analysis
            const volData = calculateRollingVolatility(filteredHistory, 20);
            const currentVol = volData.length > 0 ? volData[volData.length - 1].vol : 0;
            const avgVol = volData.length > 0 ? (volData.reduce((a, b) => a + b.vol, 0) / volData.length) : 0;
            const volRatio = avgVol > 0 ? currentVol / avgVol : 1;

            // Prediction quality
            const predQuality = analyzePredictionQuality(trades);

            // Data Quality Score (0-100)
            let qualityScore = 100;
            qualityScore -= gaps.length * 2; // -2 per gap
            qualityScore -= missing.length * 5; // -5 per missing period
            qualityScore -= anomalies.length * 3; // -3 per anomaly
            qualityScore = Math.max(0, Math.min(100, qualityScore));

            // Drift Alert Level
            let alertLevel = "LOW";
            let alertColor = "text-emerald-600";
            if (klDivergence > 0.25 || psiScore > 0.35 || volRatio > 2.0) {
                alertLevel = "CRITICAL";
                alertColor = "text-purple-600";
            } else if (klDivergence > 0.15 || psiScore > 0.25 || volRatio > 1.5) {
                alertLevel = "HIGH";
                alertColor = "text-rose-600";
            } else if (klDivergence > 0.08 || psiScore > 0.15 || volRatio > 1.2) {
                alertLevel = "MEDIUM";
                alertColor = "text-orange-600";
            }

            // Update KPIs
            document.getElementById('drift-quality-score').textContent = qualityScore.toFixed(0) + "%";
            document.getElementById('drift-quality-score').className = `text-2xl font-black ${qualityScore > 80 ? 'text-emerald-600' : qualityScore > 60 ? 'text-orange-600' : 'text-rose-600'}`;

            document.getElementById('drift-gaps-count').textContent = gaps.length;
            document.getElementById('drift-missing-count').textContent = missing.length;
            document.getElementById('drift-alert-level').textContent = alertLevel;
            document.getElementById('drift-alert-level').className = `text-2xl font-black ${alertColor}`;

            // Update drift metrics
            document.getElementById('drift-kl-value').textContent = klDivergence.toFixed(4);
            document.getElementById('drift-kl-value').className = `text-lg font-black ${klDivergence > 0.15 ? 'text-rose-600' : klDivergence > 0.08 ? 'text-orange-600' : 'text-emerald-600'}`;

            document.getElementById('drift-psi-value').textContent = psiScore.toFixed(4);
            document.getElementById('drift-psi-value').className = `text-lg font-black ${psiScore > 0.25 ? 'text-rose-600' : psiScore > 0.15 ? 'text-orange-600' : 'text-emerald-600'}`;

            // Update prediction metrics
            document.getElementById('pred-accuracy').textContent = (predQuality.accuracy * 100).toFixed(1) + "%";
            document.getElementById('pred-precision').textContent = (predQuality.precision * 100).toFixed(1) + "%";
            document.getElementById('pred-f1').textContent = predQuality.f1.toFixed(3);

            // Update volatility metrics
            document.getElementById('vol-current').textContent = (currentVol * 100).toFixed(2) + "%";
            document.getElementById('vol-avg').textContent = (avgVol * 100).toFixed(2) + "%";
            document.getElementById('vol-ratio').textContent = volRatio.toFixed(2) + "x";

            let regime = "NORMAL";
            let regimeClass = "bg-emerald-50 border-emerald-200";
            if (volRatio > 2.0) {
                regime = "EXTREME";
                regimeClass = "bg-rose-50 border-rose-200";
            } else if (volRatio > 1.5) {
                regime = "HIGH";
                regimeClass = "bg-orange-50 border-orange-200";
            } else if (volRatio < 0.7) {
                regime = "LOW";
                regimeClass = "bg-blue-50 border-blue-200";
            }

            document.getElementById('vol-regime').textContent = regime;
            document.getElementById('vol-regime-box').className = `p-3 rounded border text-center ${regimeClass}`;

            // Update financial impact summary cards (apply FX conversion)
            document.getElementById('total-drift-loss-amount').textContent = fmtMoney(totalGapLoss * driftFx);
            document.getElementById('total-drift-loss-pct').textContent = `${Math.abs(totalGapLossPct).toFixed(2)}% of portfolio`;

            document.getElementById('sl-hit-by-gaps-count').textContent = slHitByGaps;
            document.getElementById('sl-hit-by-gaps-amount').textContent = fmtMoney(slHitLoss * driftFx) + ' lost';

            document.getElementById('other-issues-count').textContent = otherIssues.length;

            // Render gaps table
            renderGapsTable();

            // Update issue lists
            updateIssuesList('missing-list', missing.map(m => ({
                text: `${m.days} days gap`,
                detail: `${fmtDate(m.from)} to ${fmtDate(m.to)}`
            })));

            updateIssuesList('other-issues-list', otherIssues.slice(0, 15).map(issue => ({
                text: `[${issue.severity}] ${issue.type}`,
                detail: issue.description
            })));

            // Render charts
            renderDriftReturnsChart(baselineDist, recentDist);
            renderPredictionChart(predQuality.timeline || []);
            renderVolatilityChart(volData);

            // Update symbol-level drift table
            updateSymbolDriftTable(filteredHistory);
        }

        function updateIssuesList(elementId, items) {
            const el = document.getElementById(elementId);
            if (!el) return;

            if (items.length === 0) {
                el.innerHTML = '<div class="text-xs text-slate-400 italic">No issues detected</div>';
                return;
            }

            el.innerHTML = items.map(item => `
                <div class="p-2 bg-white rounded border border-slate-200 text-xs">
                    <div class="font-bold text-slate-700">${item.text}</div>
                    ${item.detail ? `<div class="text-slate-500 text-[10px] mt-1">${item.detail}</div>` : ''}
                </div>
            `).join('');
        }

        function renderDriftReturnsChart(baseline, recent) {
            const ctx = document.getElementById('drift-returns-chart');
            if (!ctx) return;

            if (driftChartsInstances.returns) {
                driftChartsInstances.returns.destroy();
            }

            const labels = baseline.bins.slice(0, -1).map((b, i) => {
                const start = (b * 100).toFixed(1);
                const end = (baseline.bins[i + 1] * 100).toFixed(1);
                return `${start}% to ${end}%`;
            });

            driftChartsInstances.returns = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [
                        {
                            label: 'Baseline Period',
                            data: baseline.counts,
                            backgroundColor: 'rgba(59, 130, 246, 0.5)',
                            borderColor: 'rgb(59, 130, 246)',
                            borderWidth: 1
                        },
                        {
                            label: 'Recent Period',
                            data: recent.counts,
                            backgroundColor: 'rgba(168, 85, 247, 0.5)',
                            borderColor: 'rgb(168, 85, 247)',
                            borderWidth: 1
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: true, position: 'top' },
                        tooltip: {
                            callbacks: {
                                label: (ctx) => `${ctx.dataset.label}: ${(ctx.parsed.y * 100).toFixed(2)}%`
                            }
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            ticks: {
                                callback: (val) => (val * 100).toFixed(1) + '%'
                            }
                        }
                    }
                }
            });
        }

        function renderPredictionChart(timeline) {
            const ctx = document.getElementById('drift-prediction-chart');
            if (!ctx) return;

            if (driftChartsInstances.prediction) {
                driftChartsInstances.prediction.destroy();
            }

            if (!timeline || timeline.length === 0) {
                // Show placeholder
                return;
            }

            driftChartsInstances.prediction = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: timeline.map(t => fmtDate(t.date || t.Date)),
                    datasets: [{
                        label: 'Win Rate (Accuracy)',
                        data: timeline.map(t => t.accuracy),
                        borderColor: 'rgb(168, 85, 247)',
                        backgroundColor: 'rgba(168, 85, 247, 0.1)',
                        fill: true,
                        tension: 0.3,
                        pointRadius: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            max: 1,
                            ticks: {
                                callback: (val) => (val * 100).toFixed(0) + '%'
                            }
                        }
                    }
                }
            });
        }

        function renderVolatilityChart(volData) {
            const ctx = document.getElementById('drift-volatility-chart');
            if (!ctx) return;

            if (driftChartsInstances.volatility) {
                driftChartsInstances.volatility.destroy();
            }

            if (!volData || volData.length === 0) return;

            const avgVol = volData.reduce((a, b) => a + b.vol, 0) / volData.length;

            driftChartsInstances.volatility = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: volData.map(v => fmtDate(v.date)),
                    datasets: [
                        {
                            label: 'Rolling Volatility (20d)',
                            data: volData.map(v => v.vol * 100),
                            borderColor: 'rgb(99, 102, 241)',
                            backgroundColor: 'rgba(99, 102, 241, 0.1)',
                            fill: true,
                            tension: 0.3
                        },
                        {
                            label: 'Average',
                            data: volData.map(() => avgVol * 100),
                            borderColor: 'rgb(239, 68, 68)',
                            borderDash: [5, 5],
                            borderWidth: 2,
                            pointRadius: 0
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: true, position: 'top' }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            ticks: {
                                callback: (val) => val.toFixed(1) + '%'
                            }
                        }
                    }
                }
            });
        }

        // Store drift data globally for filtering/sorting
        window.DRIFT_DATA = [];

        function updateSymbolDriftTable(history) {
            const tbody = document.getElementById('symbol-drift-body');
            if (!tbody) return;

            // Get all unique symbols from current positions
            const currentSnapshot = history[history.length - 1];
            if (!currentSnapshot || !currentSnapshot.positions) {
                tbody.innerHTML = '<tr><td colspan="7" class="px-4 py-8 text-center text-slate-400">No positions to analyze</td></tr>';
                window.DRIFT_DATA = [];
                return;
            }

            // Build drift data
            window.DRIFT_DATA = currentSnapshot.positions.map(pos => {
                // Simplified metrics - in production, you'd calculate these properly
                const returnsDrift = Math.random() * 0.3; // Placeholder
                const volDrift = Math.random() * 0.4; // Placeholder
                const gaps = Math.floor(Math.random() * 3);
                const missing = Math.floor(Math.random() * 2);

                const healthScore = 100 - (returnsDrift * 100) - (volDrift * 50) - (gaps * 5) - (missing * 10);

                let status = "HEALTHY";
                let statusClass = "drift-badge low";
                if (healthScore < 50) {
                    status = "CRITICAL";
                    statusClass = "drift-badge critical";
                } else if (healthScore < 70) {
                    status = "WARNING";
                    statusClass = "drift-badge high";
                } else if (healthScore < 85) {
                    status = "WATCH";
                    statusClass = "drift-badge medium";
                }

                return {
                    symbol: pos.symbol,
                    returnsDrift: returnsDrift,
                    volDrift: volDrift,
                    gaps: gaps,
                    missing: missing,
                    healthScore: healthScore,
                    status: status,
                    statusClass: statusClass
                };
            });

            // Render table
            renderDriftTable();
        }

        function renderDriftTable() {
            const tbody = document.getElementById('symbol-drift-body');
            if (!tbody || !window.DRIFT_DATA) return;

            if (window.DRIFT_DATA.length === 0) {
                tbody.innerHTML = '<tr><td colspan="7" class="px-4 py-8 text-center text-slate-400">No data</td></tr>';
                return;
            }

            const rows = window.DRIFT_DATA.map(row => `
                <tr class="hover:bg-slate-50">
                    <td class="px-4 py-3 font-mono font-bold text-slate-800">${row.symbol}</td>
                    <td class="px-4 py-3 text-center ${row.returnsDrift > 0.15 ? 'text-rose-600' : 'text-emerald-600'} font-bold">${row.returnsDrift.toFixed(3)}</td>
                    <td class="px-4 py-3 text-center ${row.volDrift > 0.25 ? 'text-rose-600' : 'text-emerald-600'} font-bold">${row.volDrift.toFixed(3)}</td>
                    <td class="px-4 py-3 text-center ${row.gaps > 1 ? 'text-orange-600' : 'text-slate-600'}">${row.gaps}</td>
                    <td class="px-4 py-3 text-center ${row.missing > 0 ? 'text-orange-600' : 'text-slate-600'}">${row.missing}</td>
                    <td class="px-4 py-3 text-center font-bold ${row.healthScore > 85 ? 'text-emerald-600' : row.healthScore > 70 ? 'text-orange-600' : 'text-rose-600'}">${row.healthScore.toFixed(0)}%</td>
                    <td class="px-4 py-3 text-center"><span class="${row.statusClass}">${row.status}</span></td>
                </tr>
            `).join('');

            tbody.innerHTML = rows;
        }

        // Sorting state for drift table
        let driftSortState = { column: null, direction: 1 };

        function sortDriftTable(column) {
            if (!window.DRIFT_DATA || window.DRIFT_DATA.length === 0) return;

            // Toggle direction if same column, otherwise default to ascending
            if (driftSortState.column === column) {
                driftSortState.direction *= -1;
            } else {
                driftSortState.column = column;
                driftSortState.direction = 1;
            }

            window.DRIFT_DATA.sort((a, b) => {
                let valA = a[column];
                let valB = b[column];

                // String comparison for symbol and status
                if (typeof valA === 'string') {
                    return valA.localeCompare(valB) * driftSortState.direction;
                }

                // Numeric comparison
                return (valA - valB) * driftSortState.direction;
            });

            renderDriftTable();
        }

        // Filtering
        function filterDriftTable() {
            if (!window.DRIFT_DATA || window.DRIFT_DATA.length === 0) return;

            const tbody = document.getElementById('symbol-drift-body');
            if (!tbody) return;

            // Get filter values
            const filters = {
                symbol: document.getElementById('filter-drift-symbol')?.value.toLowerCase() || '',
                returnsDrift: document.getElementById('filter-drift-returnsDrift')?.value.trim() || '',
                volDrift: document.getElementById('filter-drift-volDrift')?.value.trim() || '',
                gaps: document.getElementById('filter-drift-gaps')?.value.trim() || '',
                missing: document.getElementById('filter-drift-missing')?.value.trim() || '',
                healthScore: document.getElementById('filter-drift-healthScore')?.value.trim() || '',
                status: document.getElementById('filter-drift-status')?.value || ''
            };

            const filtered = window.DRIFT_DATA.filter(row => {
                // Symbol filter (contains)
                if (filters.symbol && !row.symbol.toLowerCase().includes(filters.symbol)) {
                    return false;
                }

                // Status filter (exact match)
                if (filters.status && row.status !== filters.status) {
                    return false;
                }

                // Numeric filters (supports <, >, <=, >=, =)
                if (filters.returnsDrift && !matchNumericFilter(row.returnsDrift, filters.returnsDrift)) return false;
                if (filters.volDrift && !matchNumericFilter(row.volDrift, filters.volDrift)) return false;
                if (filters.gaps && !matchNumericFilter(row.gaps, filters.gaps)) return false;
                if (filters.missing && !matchNumericFilter(row.missing, filters.missing)) return false;
                if (filters.healthScore && !matchNumericFilter(row.healthScore, filters.healthScore)) return false;

                return true;
            });

            // Render filtered data
            if (filtered.length === 0) {
                tbody.innerHTML = '<tr><td colspan="7" class="px-4 py-8 text-center text-slate-400">No results match your filters</td></tr>';
                return;
            }

            const rows = filtered.map(row => `
                <tr class="hover:bg-slate-50">
                    <td class="px-4 py-3 font-mono font-bold text-slate-800">${row.symbol}</td>
                    <td class="px-4 py-3 text-center ${row.returnsDrift > 0.15 ? 'text-rose-600' : 'text-emerald-600'} font-bold">${row.returnsDrift.toFixed(3)}</td>
                    <td class="px-4 py-3 text-center ${row.volDrift > 0.25 ? 'text-rose-600' : 'text-emerald-600'} font-bold">${row.volDrift.toFixed(3)}</td>
                    <td class="px-4 py-3 text-center ${row.gaps > 1 ? 'text-orange-600' : 'text-slate-600'}">${row.gaps}</td>
                    <td class="px-4 py-3 text-center ${row.missing > 0 ? 'text-orange-600' : 'text-slate-600'}">${row.missing}</td>
                    <td class="px-4 py-3 text-center font-bold ${row.healthScore > 85 ? 'text-emerald-600' : row.healthScore > 70 ? 'text-orange-600' : 'text-rose-600'}">${row.healthScore.toFixed(0)}%</td>
                    <td class="px-4 py-3 text-center"><span class="${row.statusClass}">${row.status}</span></td>
                </tr>
            `).join('');

            tbody.innerHTML = rows;
        }

        function matchNumericFilter(value, filterStr) {
            filterStr = filterStr.trim();
            if (!filterStr) return true;

            // Check for operators
            let match;
            if ((match = filterStr.match(/^>=\s*(.+)$/))) {
                return value >= parseFloat(match[1]);
            } else if ((match = filterStr.match(/^<=\s*(.+)$/))) {
                return value <= parseFloat(match[1]);
            } else if ((match = filterStr.match(/^>\s*(.+)$/))) {
                return value > parseFloat(match[1]);
            } else if ((match = filterStr.match(/^<\s*(.+)$/))) {
                return value < parseFloat(match[1]);
            } else if ((match = filterStr.match(/^=\s*(.+)$/))) {
                return Math.abs(value - parseFloat(match[1])) < 0.001;
            } else {
                // Default: exact match
                const num = parseFloat(filterStr);
                if (!isNaN(num)) {
                    return Math.abs(value - num) < 0.001;
                }
            }

            return true;
        }

        function clearDriftFilters() {
            document.getElementById('filter-drift-symbol').value = '';
            document.getElementById('filter-drift-returnsDrift').value = '';
            document.getElementById('filter-drift-volDrift').value = '';
            document.getElementById('filter-drift-gaps').value = '';
            document.getElementById('filter-drift-missing').value = '';
            document.getElementById('filter-drift-healthScore').value = '';
            document.getElementById('filter-drift-status').value = '';

            renderDriftTable();
        }

        // ===================================
        // GAPS TABLE - Sorting & Filtering
        // ===================================

        let gapsSortState = { column: null, direction: 1 };

        function sortGapsTable(column) {
            if (!window.GAPS_DATA || window.GAPS_DATA.length === 0) return;

            if (gapsSortState.column === column) {
                gapsSortState.direction *= -1;
            } else {
                gapsSortState.column = column;
                gapsSortState.direction = 1;
            }

            window.GAPS_DATA.sort((a, b) => {
                let valA = a[column];
                let valB = b[column];

                if (typeof valA === 'string') {
                    return valA.localeCompare(valB) * gapsSortState.direction;
                }

                return (valA - valB) * gapsSortState.direction;
            });

            renderGapsTable();
        }

        function filterGapsTable() {
            if (!window.GAPS_DATA || window.GAPS_DATA.length === 0) return;

            const tbody = document.getElementById('gaps-table-body');
            if (!tbody) return;

            const filters = {
                date: document.getElementById('filter-gaps-date')?.value.trim() || '',
                symbol: document.getElementById('filter-gaps-symbol')?.value.toLowerCase() || '',
                gapPct: parseFloat(document.getElementById('filter-gaps-gapPct')?.value) || 0,
                slHit: document.getElementById('filter-gaps-slHit')?.value || '',
                impact: document.getElementById('filter-gaps-impact')?.value.trim() || ''
            };

            const filtered = window.GAPS_DATA.filter(row => {
                if (filters.date && !row.date.includes(filters.date)) return false;
                if (filters.symbol && !row.symbol.toLowerCase().includes(filters.symbol)) return false;
                if (filters.slHit) {
                    const slHitValue = row.slHit ? 'YES' : 'NO';
                    if (slHitValue !== filters.slHit) return false;
                }
                // Simple minimum filter for gap % (absolute value)
                if (filters.gapPct > 0 && Math.abs(row.gapPct * 100) < filters.gapPct) return false;
                if (filters.impact && !matchNumericFilter(row.impact, filters.impact)) return false;

                return true;
            });

            if (filtered.length === 0) {
                tbody.innerHTML = '<tr><td colspan="7" class="px-4 py-8 text-center text-slate-400">No results match your filters</td></tr>';
                return;
            }

            const rows = filtered.map(row => `
                <tr class="hover:bg-slate-50 ${row.slHit ? 'bg-rose-50' : ''}">
                    <td class="px-4 py-3 text-sm text-slate-700">${fmtDate(row.date)}</td>
                    <td class="px-4 py-3 font-mono font-bold text-slate-800">${row.symbol}</td>
                    <td class="px-4 py-3 text-right font-bold ${row.gapPct > 0 ? 'text-emerald-600' : 'text-rose-600'}">
                        ${(row.gapPct * 100).toFixed(2)}%
                    </td>
                    <td class="px-4 py-3 text-right text-slate-600">${fmtMoney(row.priceBefore)}</td>
                    <td class="px-4 py-3 text-right text-slate-600">${fmtMoney(row.priceAfter)}</td>
                    <td class="px-4 py-3 text-center">
                        ${row.slHit ? '<span class="px-2 py-1 bg-rose-100 text-rose-700 text-xs font-bold rounded">YES</span>' : '<span class="text-slate-400 text-xs">No</span>'}
                    </td>
                    <td class="px-4 py-3 text-right font-bold ${row.impact < 0 ? 'text-rose-600' : row.impact > 0 ? 'text-emerald-600' : 'text-slate-600'}">
                        ${row.impact !== 0 ? fmtMoney(row.impact) : '--'}
                    </td>
                </tr>
            `).join('');

            tbody.innerHTML = rows;
        }

        function renderGapsTable() {
            const tbody = document.getElementById('gaps-table-body');
            if (!tbody || !window.GAPS_DATA) return;

            if (window.GAPS_DATA.length === 0) {
                tbody.innerHTML = '<tr><td colspan="7" class="px-4 py-8 text-center text-slate-400">No gaps detected</td></tr>';
                return;
            }

            // Get FX rate for currency conversion
            const fx = window.DRIFT_FX || 1.0;

            const rows = window.GAPS_DATA.map(row => {
                // Apply FX to monetary values (prices and impact)
                const priceBefore = row.priceBefore * fx;
                const priceAfter = row.priceAfter * fx;
                const impact = row.impact * fx;

                return `
                <tr class="hover:bg-slate-50 ${row.slHit ? 'bg-rose-50' : ''}">
                    <td class="px-4 py-3 text-sm text-slate-700">${fmtDate(row.date)}</td>
                    <td class="px-4 py-3 font-mono font-bold text-slate-800">${row.symbol}</td>
                    <td class="px-4 py-3 text-right font-bold ${row.gapPct > 0 ? 'text-emerald-600' : 'text-rose-600'}">
                        ${(row.gapPct * 100).toFixed(2)}%
                    </td>
                    <td class="px-4 py-3 text-right text-slate-600">${fmtMoney(priceBefore)}</td>
                    <td class="px-4 py-3 text-right text-slate-600">${fmtMoney(priceAfter)}</td>
                    <td class="px-4 py-3 text-center">
                        ${row.slHit ? '<span class="px-2 py-1 bg-rose-100 text-rose-700 text-xs font-bold rounded">YES</span>' : '<span class="text-slate-400 text-xs">No</span>'}
                    </td>
                    <td class="px-4 py-3 text-right font-bold ${impact < 0 ? 'text-rose-600' : impact > 0 ? 'text-emerald-600' : 'text-slate-600'}">
                        ${impact !== 0 ? fmtMoney(impact) : '--'}
                    </td>
                </tr>
            `}).join('');

            tbody.innerHTML = rows;
        }

        function clearGapsFilters() {
            document.getElementById('filter-gaps-date').value = '';
            document.getElementById('filter-gaps-symbol').value = '';
            document.getElementById('filter-gaps-gapPct').value = '';
            document.getElementById('filter-gaps-slHit').value = '';
            document.getElementById('filter-gaps-impact').value = '';

            renderGapsTable();
        }

        // ===================================
        // OTHER ISSUES DETECTION
        // ===================================

        function detectOtherIssues(history, trades) {
            const issues = [];

            if (!trades || trades.length === 0) return issues;

            // 1. Slippage detection (entry price vs market)
            const slippageThreshold = 0.01; // 1%
            trades.forEach(t => {
                const action = (t.Action || '').toUpperCase();
                if (action.includes('BUY')) {
                    // Find market price at that date
                    const snap = history.find(h => h.date === t.Date);
                    if (snap && snap.positions) {
                        const pos = snap.positions.find(p => p.symbol === t.Symbol);
                        if (pos && pos.price) {
                            const slippage = Math.abs((t.Price - pos.price) / pos.price);
                            if (slippage > slippageThreshold) {
                                issues.push({
                                    type: 'SLIPPAGE',
                                    date: t.Date,
                                    symbol: t.Symbol,
                                    severity: slippage > 0.03 ? 'HIGH' : 'MEDIUM',
                                    description: `High slippage: ${(slippage * 100).toFixed(2)}% on ${t.Action}`,
                                    impact: (t.Price - pos.price) * t.Shares
                                });
                            }
                        }
                    }
                }
            });

            // 2. Low liquidity detection (small volumes)
            // This would require volume data - placeholder for now
            // issues.push({ type: 'LOW_LIQUIDITY', ...})

            // 3. Spread anomalies
            // Would need bid/ask data - placeholder

            // 4. Corporate actions
            history.forEach((snap, i) => {
                if (i > 0 && snap.positions) {
                    const prevSnap = history[i - 1];
                    snap.positions.forEach(pos => {
                        const prevPos = prevSnap.positions?.find(p => p.symbol === pos.symbol);
                        if (prevPos) {
                            // Check for unusual share count changes (split/reverse split)
                            if (prevPos.shares > 0 && pos.shares !== prevPos.shares) {
                                const shareRatio = pos.shares / prevPos.shares;
                                const priceRatio = prevPos.price > 0 ? pos.price / prevPos.price : 1;

                                // If shares changed but not price, might be corp action
                                if (Math.abs(shareRatio - 1) > 0.1 && Math.abs(priceRatio * shareRatio - 1) > 0.1) {
                                    issues.push({
                                        type: 'CORPORATE_ACTION',
                                        date: snap.date,
                                        symbol: pos.symbol,
                                        severity: 'INFO',
                                        description: `Possible stock split/reverse split detected (shares: ${prevPos.shares} â†’ ${pos.shares})`,
                                        impact: 0
                                    });
                                }
                            }
                        }
                    });
                }
            });

            console.log(`detectOtherIssues: Found ${issues.length} issues`);
            return issues;
        }

        
    </script>
    <!-- Stats Config Modal -->
    <div id="modal-stats-config"
        class="fixed inset-0 bg-slate-900/50 z-[100] hidden flex items-center justify-center backdrop-blur-sm">
        <div class="bg-white rounded-xl shadow-2xl w-96 max-h-[80vh] flex flex-col">
            <div class="p-4 border-b border-slate-100 flex justify-between items-center">
                <h3 class="font-bold text-slate-800">Configure Stats</h3>
                <button onclick="closeStatsConfig()" class="text-slate-400 hover:text-slate-600"><i
                        class="fa-solid fa-times"></i></button>
            </div>
            <div id="stats-config-list" class="p-4 overflow-y-auto flex-1 space-y-1"></div>
            <div class="p-4 border-t border-slate-100 bg-slate-50 text-right">
                <button onclick="closeStatsConfig()"
                    class="px-4 py-2 bg-indigo-600 text-white rounded text-sm font-bold shadow hover:bg-indigo-700">Done</button>
            </div>
        </div>
    </div>

    <!-- Chart Modal -->
    <div id="modal-chart-detail"
        class="fixed inset-0 bg-slate-900/80 z-[100] hidden flex items-center justify-center backdrop-blur-sm"
        onclick="closeChartDetail()">
        <div class="bg-white rounded-xl shadow-2xl w-[90vw] md:w-[800px] h-[500px] flex flex-col"
            onclick="event.stopPropagation()">
            <div class="p-4 border-b border-slate-100 flex justify-between items-center">
                <h3 id="modal-chart-title" class="font-bold text-slate-800">Chart</h3>
                <button onclick="closeChartDetail()" class="text-slate-400 hover:text-slate-600"><i
                        class="fa-solid fa-times"></i></button>
            </div>
            <div class="p-4 flex-1">
                <canvas id="detailChart"></canvas>
            </div>
        </div>
    </div>

    <script>
        // --- NEW STATS CONFIG LOGIC ---
        const STATS_DEF = {
            "total_equity": { label: "Total Equity", color: "text-emerald-600", chart: "chart-equity", fmt: (v, fx, c) => fmtMoney(v * fx, c) },
            "cash": { label: "Cash", color: "text-blue-600", chart: "chart-cash", fmt: (v, fx, c) => fmtMoney(v * fx, c) },
            "positions_value": { label: "Positions Value", color: "text-slate-800", chart: "chart-positions-val", fmt: (v, fx, c) => fmtMoney(v * fx, c) },
            "realized": { label: "Realized P&L", color: "text-slate-800", chart: "chart-realized", fmt: (v, fx, c) => fmtMoney(v * fx, c) },
            "r2": { label: "Linearity (R2)", color: "text-violet-600", chart: "chart-r2", fmt: (v) => (v !== undefined && v !== null) ? v.toFixed(2) : '--' },
            "sharpe": { label: "Sharpe Ratio", color: "text-purple-600", chart: "chart-sharpe", fmt: (v) => (v !== undefined && v !== null) ? v.toFixed(2) : '--' },
            "vol": { label: "Volatility", color: "text-orange-600", chart: "chart-vol", fmt: (v) => (v !== undefined && v !== null) ? (v * 100).toFixed(2) + '%' : '--' },
            "max_dd": { label: "Max Drawdown", color: "text-rose-600", chart: "chart-max-dd", fmt: (v) => (v !== undefined && v !== null) ? (v * 100).toFixed(2) + '%' : '--' },
            "winrate": { label: "Win Rate", color: "text-emerald-500", chart: "chart-winrate", fmt: (v) => (v !== undefined && v !== null) ? (v * 100).toFixed(1) + '%' : '--' },
            "trades_count": { label: "Total Trades", color: "text-slate-700", chart: "chart-trades", fmt: (v) => v || 0 },
            "max_loss": { label: "Max Loss (VaR)", color: "text-rose-600", chart: "chart-risk", fmt: (v, fx, c) => fmtMoney(Math.abs(v || 0) * fx, c) },
            "beta": { label: "Beta", color: "text-indigo-600", chart: "chart-beta", fmt: (v) => (v !== undefined && v !== null) ? v.toFixed(2) : '--' }
        };

        // Default Config
        let STATS_CONFIG = JSON.parse(localStorage.getItem('STATS_CONFIG')) || ['total_equity', 'cash', 'r2', 'trades_count', 'sharpe', 'max_dd', 'winrate'];

        function renderStatsGrid() {
            const grid = document.getElementById('stats-grid');
            if (!grid) return;
            grid.innerHTML = '';

            STATS_CONFIG.forEach(key => {
                const def = STATS_DEF[key];
                if (!def) return;

                const div = document.createElement('div');
                div.className = "p-3 bg-slate-50 rounded-xl border border-slate-100 relative overflow-hidden h-24 hover:border-slate-300 transition-colors group";
                if (def.chart) {
                    div.style.cursor = "pointer";
                    div.onclick = () => openStatChart(key);
                }

                let chartHtml = '';
                if (typeof def.chart === 'string') {
                    chartHtml = `<canvas id="${def.chart}" width="150" height="40" class="absolute bottom-0 left-0 w-full h-12 opacity-20 group-hover:opacity-40 transition-opacity"></canvas>`;
                }

                // Add secondary percentage display for monetary metrics
                const needsPct = ['total_equity', 'cash', 'positions_value', 'realized', 'max_loss'].includes(key);
                const pctHtml = needsPct ? `<span class="text-[10px] font-bold text-slate-400 ml-1" id="stat-pct-${key}"></span>` : '';

                div.innerHTML = `
                        <div class="relative z-10 pointer-events-none">
                        <div class="text-[10px] text-slate-400 uppercase font-bold tracking-wide">${def.label}</div>
                        <div class="flex items-baseline gap-1 mt-1">
                            <div class="text-xs font-black ${def.color} tracking-tight" id="stat-val-${key}">--</div>
                            ${pctHtml}
                        </div>
                    </div>
                        ${chartHtml}
                    `;
                grid.appendChild(div);
            });
        }

        function updateStatsGridValues(snap, fx, sub, stats) {
            if (!document.getElementById('stats-grid').children.length) renderStatsGrid();

            // Always use dynamically calculated stats from calculateWindowStats()
            // This ensures consistency with the KPIs which also use calculateWindowStats()
            // The 'stats' parameter already contains the correct window-based calculations

            // PRE-CALCULATE stats for all sparkline points ONCE (optimization)
            // This avoids calling calculateWindowStats() multiple times for each metric
            let sparklineStatsCache = null;
            const dynamicMetrics = ['r2', 'sharpe', 'vol', 'max_dd', 'winrate', 'trades_count'];
            const needsSparklineCache = STATS_CONFIG.some(k => dynamicMetrics.includes(k));

            if (needsSparklineCache && sub && sub.length > 0) {
                sparklineStatsCache = sub.map(d => {
                    const idx = DATA.history.findIndex(h => h.date === d.date);
                    if (idx >= 0) {
                        return calculateWindowStats(idx);
                    }
                    return { r2: 0, sharpe: 0, vol: 0, max_dd: 0, winrate: 0, trades_count: 0 };
                });
            }

            STATS_CONFIG.forEach((key, configIdx) => {
                const def = STATS_DEF[key];
                const elVal = document.getElementById(`stat-val-${key}`);
                if (!elVal) return;

                let val = 0; // Default
                // Snapshot-specific values (point-in-time)
                if (key === 'total_equity') val = snap.equity;
                else if (key === 'cash') val = snap.cash;
                else if (key === 'positions_value') val = snap.positions ? snap.positions.reduce((a, b) => a + (b.value || 0), 0) : 0;
                else if (key === 'realized') val = snap.realized || 0;
                else if (key === 'max_loss') val = snap.risk || 0;
                else if (key === 'beta') val = snap.beta || 0;
                // Window-calculated metrics (from start to current Time Machine position)
                // These must match the KPIs which use calculateWindowStats()
                else if (stats && stats[key] !== undefined) {
                    val = stats[key];
                }

                // Format main value
                elVal.innerText = def.fmt(val, fx, STATE.currency);

                // Update percentage for monetary metrics
                const elPct = document.getElementById(`stat-pct-${key}`);
                if (elPct && snap.equity > 0) {
                    // Calculate percentage relative to total equity
                    let pct = 0;
                    if (key === 'total_equity') {
                        // Show return percentage from initial
                        const initialEquity = DATA.history && DATA.history[0] ? DATA.history[0].equity : snap.equity;
                        pct = initialEquity > 0 ? ((snap.equity - initialEquity) / initialEquity * 100) : 0;
                        elPct.innerText = `(${pct >= 0 ? '+' : ''}${pct.toFixed(1)}%)`;
                        elPct.className = pct >= 0 ? "text-[10px] font-bold text-emerald-500 ml-1" : "text-[10px] font-bold text-rose-500 ml-1";
                    } else if (key === 'cash') {
                        pct = (snap.cash / snap.equity * 100);
                        elPct.innerText = `(${pct.toFixed(1)}%)`;
                        elPct.className = "text-[10px] font-bold text-slate-400 ml-1";
                    } else if (key === 'positions_value') {
                        const posVal = snap.positions ? snap.positions.reduce((a, b) => a + (b.value || 0), 0) : 0;
                        pct = (posVal / snap.equity * 100);
                        elPct.innerText = `(${pct.toFixed(1)}%)`;
                        elPct.className = "text-[10px] font-bold text-slate-400 ml-1";
                    } else if (key === 'realized') {
                        const initialEquity = DATA.history && DATA.history[0] ? DATA.history[0].equity : snap.equity;
                        pct = initialEquity > 0 ? ((snap.realized || 0) / initialEquity * 100) : 0;
                        elPct.innerText = `(${pct >= 0 ? '+' : ''}${pct.toFixed(1)}%)`;
                        elPct.className = pct >= 0 ? "text-[10px] font-bold text-emerald-500 ml-1" : "text-[10px] font-bold text-rose-500 ml-1";
                    } else if (key === 'max_loss') {
                        // Max loss as % of current equity (risk if all stops hit)
                        pct = snap.equity > 0 ? (Math.abs(snap.risk || 0) / snap.equity * 100) : 0;
                        elPct.innerText = `(${pct.toFixed(1)}%)`;
                        elPct.className = "text-[10px] font-bold text-rose-400 ml-1";
                    }
                }

                // Draw Chart (Sparkline) - Only if ID string provided
                // Use single FX rate (fx parameter) for performance - sparklines are visual approximations
                if (typeof def.chart === 'string' && sub) {
                    let data = [];
                    let color = '#64748b'; // default

                    if (key === 'total_equity') {
                        data = sub.map(d => d.equity * fx);
                        color = '#10b981';
                    }
                    else if (key === 'cash') {
                        data = sub.map(d => d.cash * fx);
                        color = '#3b82f6';
                    }
                    else if (key === 'positions_value') {
                        data = sub.map(d => {
                            const pv = d.positions ? d.positions.reduce((a, b) => a + (b.value || 0), 0) : 0;
                            return pv * fx;
                        });
                        color = '#334155';
                    }
                    else if (key === 'realized') {
                        data = sub.map(d => (d.realized || 0) * fx);
                        color = '#059669';
                    }
                    else if (key === 'max_loss') {
                        data = sub.map(d => (d.risk || 0) * fx);
                        color = '#e11d48';
                    }
                    else if (key === 'beta') {
                        data = sub.map(d => d.beta || 0);
                        color = '#7c3aed';
                    }
                    else if (dynamicMetrics.includes(key) && sparklineStatsCache) {
                        // Use pre-calculated stats from cache
                        data = sparklineStatsCache.map(s => s[key] || 0);
                        // Set colors based on metric type
                        if (key === 'r2') color = '#8b5cf6';
                        else if (key === 'sharpe') color = '#a855f7';
                        else if (key === 'vol') color = '#f97316';
                        else if (key === 'max_dd') color = '#ef4444';
                        else if (key === 'winrate') color = '#22c55e';
                        else if (key === 'trades_count') color = '#64748b';
                    }

                    drawSparkline(def.chart, data, color);
                }
            });
        }

        function openStatsConfig() {
            const modal = document.getElementById('modal-stats-config');
            const list = document.getElementById('stats-config-list');
            if (!modal || !list) return;

            list.innerHTML = '';
            Object.keys(STATS_DEF).forEach(key => {
                const def = STATS_DEF[key];
                const isActive = STATS_CONFIG.includes(key);
                const div = document.createElement('div');
                div.innerHTML = `
                <div class="flex items-center justify-between p-2 hover:bg-slate-50 rounded cursor-pointer transition-colors" onclick="toggleStatConfig('${key}')">
                <div class="flex items-center gap-2">
                <div class="w-4 h-4 rounded border flex items-center justify-center ${isActive ? 'bg-indigo-600 border-indigo-600' : 'bg-white border-slate-300'}">
                    ${isActive ? '<i class="fa-solid fa-check text-white text-[10px]"></i>' : ''}
                </div>
                <span class="text-sm text-slate-700 font-bold">${def.label}</span>
                </div>
                </div>
            `;
                list.appendChild(div);
            });
            modal.classList.remove('hidden');
        }

        function toggleStatConfig(key) {
            if (STATS_CONFIG.includes(key)) {
                STATS_CONFIG = STATS_CONFIG.filter(k => k !== key);
            } else {
                STATS_CONFIG.push(key);
            }
            localStorage.setItem('STATS_CONFIG', JSON.stringify(STATS_CONFIG));
            renderStatsGrid();
        }

        function closeStatsConfig() {
            document.getElementById('modal-stats-config').classList.add('hidden');
        }

        // Chart Modal Logic
        let chartDetailInstance = null;
        function openStatChart(key) {
            const def = STATS_DEF[key];
            if (!def.chart) return;

            const modal = document.getElementById('modal-chart-detail');
            document.getElementById('modal-chart-title').innerText = def.label + " History";
            modal.classList.remove('hidden');

            const ctx = document.getElementById('detailChart').getContext('2d');
            if (chartDetailInstance) chartDetailInstance.destroy();

            // IMPORTANT: Respect Time Machine position - only show history up to current index
            const historySlice = DATA.history.slice(0, STATE.idx + 1);
            const dates = historySlice.map(d => fmtDate(d.date));
            let data = [];

            // Logic similar to sparkline data gathering but with dynamic FX
            if (key === 'total_equity') {
                data = historySlice.map(d => d.equity * getFX(d.date, STATE.currency));
            }
            else if (key === 'cash') {
                data = historySlice.map(d => d.cash * getFX(d.date, STATE.currency));
            }
            else if (key === 'positions_value') {
                data = historySlice.map(d => {
                    const pv = d.positions ? d.positions.reduce((a, b) => a + (b.value || 0), 0) : 0;
                    return pv * getFX(d.date, STATE.currency);
                });
            }
            else if (key === 'realized') {
                data = historySlice.map(d => (d.realized || 0) * getFX(d.date, STATE.currency));
            }
            else if (key === 'max_loss') {
                data = historySlice.map(d => (d.risk || 0) * getFX(d.date, STATE.currency));
            }
            else if (key === 'beta') {
                data = historySlice.map(d => d.beta || 0);
            }
            else if (['r2', 'sharpe', 'vol', 'max_dd', 'winrate', 'trades_count'].includes(key)) {
                // Calculate dynamic series (expensive but necessary)
                data = historySlice.map((_, i) => {
                    const stats = calculateWindowStats(i);
                    return stats[key];
                });
            }

            // Determine tooltip format based on metric type
            const isMoneyMetric = ['total_equity', 'cash', 'positions_value', 'realized', 'max_loss'].includes(key);
            const isPercentMetric = ['r2', 'vol', 'max_dd', 'winrate'].includes(key);

            chartDetailInstance = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: dates,
                    datasets: [{
                        label: def.label,
                        data: data,
                        borderColor: '#4f46e5',
                        backgroundColor: 'rgba(79, 70, 229, 0.1)',
                        borderWidth: 2,
                        pointRadius: 0,
                        fill: true,
                        tension: 0.1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: {
                        mode: 'index',
                        intersect: false,
                    },
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                label: function (context) {
                                    const val = context.parsed.y;
                                    if (isMoneyMetric) {
                                        return def.label + ': ' + fmtMoney(val, STATE.currency);
                                    } else if (isPercentMetric) {
                                        return def.label + ': ' + (val * 100).toFixed(2) + '%';
                                    } else {
                                        // Number format (sharpe, trades_count, beta)
                                        return def.label + ': ' + (typeof val === 'number' ? val.toFixed(2) : val);
                                    }
                                }
                            }
                        }
                    },
                    scales: {
                        x: { display: true, grid: { display: false } },
                        y: { display: true, beginAtZero: false, grid: { color: '#f1f5f9' } }
                    }
                }
            });
        }

        function closeChartDetail() {
            document.getElementById('modal-chart-detail').classList.add('hidden');
        }


    </script>
</body>

</html>